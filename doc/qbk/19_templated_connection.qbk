[/
    Copyright (c) 2019-2024 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:templated_connection The legacy connection class]
[nochunk]

You may encounter code using [reflink connection] or its aliases,
[reflink tcp_connection], [reflink tcp_ssl_connection],
[reflink unix_connection]. This was the
main way to create client connections until Boost 1.87, when
[reflink any_connection] became stable.

`connection` is not deprecated, but we don't recommend using it in new code.
[reflink any_connection] is simpler to use and provides the same
level of efficiency.



[heading Streams and type aliases]

[reflink connection] is templated on the [reflink Stream] class,
which implements the transport layer to read and write wire bytes.

The library provides helper type aliases for the most common cases:

[table
    [
        [Transport]
        [Stream type]
        [Type alias]
    ]
    [
        [SSL over TCP]
        [`boost::asio::ssl::stream<boost::asio::ip::tcp::socket>`]
        [
            [reflink tcp_ssl_connection]
        ]
    ]
    [
        [Plaintext TCP]
        [`boost::asio::ip::tcp::socket`]
        [
            [reflink tcp_connection]
        ]
    ]
    [
        [UNIX sockets]
        [`boost::asio::local::stream_protocol::socket`]
        [
            [reflink unix_connection]

            Only available if `BOOST_ASIO_HAS_LOCAL_SOCKETS` is defined.
        ]
    ]
]

In contrast, [reflink any_connection] is not templated.
The same three transports above can be used with `any_connection`.





[heading Constructing a connection]

`connection`'s constructor takes the same arguments as the underlying `Stream` constructor.
For a [reflink tcp_ssl_connection], we need to pass an execution context and
a __ssl_context__:

```
// The execution context, required for all I/O operations
asio::io_context ctx;

// The SSL context, required for connections that use TLS.
asio::ssl::context ssl_ctx (asio::ssl::context::tlsv12_client);

// Construct the connection. The arguments are forwarded
// to the stream type (asio::ssl::stream<asio::ip::tcp::socket>).
mysql::tcp_ssl_connection conn (ctx, ssl_ctx);
```





[heading Connection establishment]

Use [refmem connection connect] or [refmem connection async_connect] to perform connection
establishment. This function takes two parameters:

* An endpoint to connect to. The endpoint type depends on the stream type.
  For TCP connections, it's an [asioreflink ip__tcp/endpoint asio::ip::tcp::endpoint],
  which holds an IP address and a port. For UNIX sockets, it'd be an
  [asioreflink local__stream_protocol/endpoint asio::local::stream_protocol::endpoint],
  holding a UNIX path.
* A [reflink handshake_params] instance, containing all the parameters required
  to perform the MySQL handshake.

If you're using TCP, you must perform hostname resolution yourself.
For example:

```
// Resolve the hostname to get a collection of endpoints.
// default_port_string is MySQL's default port, 3306
// Hostname resolution may yield more than one host
asio::ip::tcp::resolver resolver(ctx);
auto endpoints = resolver.resolve(server_hostname, mysql::default_port_string);

// Parameters specifying how to perform the MySQL handshake operation.
// Similar to connect_params, but doesn't contain the server address and is non-owning
mysql::handshake_params params(
    mysql_username,
    mysql_password,
    "boost_mysql_examples"  // database to use
);

// Connect to the server using the first endpoint returned by the resolver
conn.connect(*endpoints.begin(), params);
```

As opposed to `connect_params`, [reflink handshake_params] does not own
the strings it contains (like username and password). It's your responsibility
to keep them alive until the connect operation finishes.




[heading Using a connection]

Once connected, [reflink connection] and [reflink any_connection] can
be used almost equivalently:

```
// Issue a query, as you would with any_connection
mysql::results result;
conn.execute("SELECT 1", result);
```

Some differences:

* Some newer APIs, like [refmemunq any_connection async_set_character_set]
  and [refmemunq any_connection async_run_pipeline], are not present
  in [reflink connection].
* By default, `connection`'s completion token is `asio::deferred`
  instead of `mysql::with_diagnostics(asio::deferred)`. When using
  coroutines with exceptions, you will get less informative errors.





[heading Terminating a connection]

As with `any_connection`, use [refmem connection close] or [refmemunq connection async_close]:

```
conn.close();
```




[heading TLS-enabled streams]

To use TLS, you must use a [reflink connection] with a 
[reflink Stream] that supports TLS. A TLS-enabled stream must inherit from
[asioreflink ssl__stream_base ssl::stream_base], like
[asioreflink ssl__stream ssl::stream] (as happens with [reflink tcp_ssl_connection]).

When using a stream type that does not support TLS, like in [reflink tcp_connection]
or [reflink unix_connection], [refmem handshake_params ssl] is ignored.





[heading UNIX sockets]


To use UNIX sockets, use [reflink unix_connection]:

```
// The execution context, required for all I/O operations
asio::io_context ctx;

// A UNIX connection requires only an execution context
mysql::unix_connection conn (ctx);

// The socket path where the server is listening
asio::local::stream_protocol::endpoint ep(socket_path);

// MySQL handshake parameters, as in the TCP case.
mysql::handshake_params params(
    mysql_username,
    mysql_password,
    "boost_mysql_examples"  // database to use
);

// Connect to the server
conn.connect(ep, params);
```





* connection exposes handshake and quit. Using these, you can perform
  transport-level connection establishment yourself, and then call
  handshake. Same for quit. These are no longer exposed in any_connection,
  since not exposing them allows for stronger guarantees.
* Once a connection closes or suffers a cancellation, tcp_ssl_connection can't
  be re-connected. It needs to be destroyed and created again.
  any_connection::connect can always be called to re-connect a connection,
  no matter what happened.
* Explain SocketStream and Stream








[heading Migrating to any_connection]

If you're using tcp_connection, tcp_ssl_connection or unix_connection,
we strongly recommend migrating to any_connection. You need to update
your `connect`, to use `connect_params` (which probably simplifies your code).

TODO: place this somewhere
[heading SSL-enabled streams]

To use SSL/TLS, you must use a [reflink connection] with a 
[reflink Stream] that supports SSL. A SSL-enabled stream must inherit from
[asioreflink ssl__stream_base ssl::stream_base]. This includes both
[asioreflink ssl__stream ssl::stream] and `boost::beast::ssl_stream`.

To make life easier, this library provides the type alias [reflink tcp_ssl_connection].

Note that there is no need to use TLS when using UNIX sockets. As the traffic doesn't
leave the machine, MySQL considers them secure, and will allow using authentication
plugins like `caching_sha2_password` even if TLS is not used.

TODO: check that evth down here is above too
[reflink any_connection] is a type-erased alternative to [reflink connection].
It's easier to use and features more functionality than plain `connection`.

When compared to [reflink connection], `any_connection`:

* Is type-erased. The type of the connection doesn't depend on the transport being used.
  Supported transports include plaintext TCP, TLS on top of TCP and UNIX domain sockets.
* Is easier to connect. For example, when using TCP, connection establishment methods will
  handle hostname resolution for you. This must be handled manually with `connection`.
* Can always be reconnected after closing it or after encountering an error.
  `connection` can't make this guarantee, especially when using TLS.
* Doesn't allow to customize the internal `Stream` type. Doing this
  allows supporting the point above.
* Has `with_diagnostics(asio::deferred)` as default completion token,
  which allows using `co_await` and getting exceptions with extra information.
* Has equivalent performance.
* Other than session establishment, it has the same API as `connection`.

`any_connection` is expected to replace `connection` in the long run.


[heading:non_sockets Streams that are not sockets]

When the `Stream` template argument for your `connection` fulfills
the __SocketStream__ type requirements, you can use the member functions
[refmem connection connect] and [refmem connection close] to establish and finish
connections with the MySQL server. If you are using any of the convenience type
aliases (TCP or UNIX, either over TLS or not), then this is your case.

If your stream type is not based on a socket, you can't use those convenience member
functions. This would be the case if you are using Windows named pipes
(i.e. [asioreflink windows__stream_handle windows::stream_handle]).
Instead, to establish a connection, you should follow these two steps,
roughly equivalent to what [refmem connection connect] does for sockets:

* Connect the underlying stream. You can access it using
  [refmem connection stream]. Use whatever connection establishment
  mechanism the stream implements. If you are using TLS, you should *not*
  perform the TLS handshake yourself, as the library will do it as part of the
  MySQL handshake.
* Perform the MySQL handshake by calling [refmem connection handshake]
  or [refmem connection async_handshake]. If the handshake operation
  fails, close the stream.
  
To clean up a connection, follow these two steps,
roughly equivalent to [refmem connection close]:

* Inform the MySQL server that you are quitting the connection
  by calling [refmem connection quit] or [refmem connection async_quit].
  This will also shutdown TLS, if it's being used. 
* Close the underlying stream.


[heading Reconnecting]

TODO: review this


After you close a connection or an error has occurred, and if its underlying [reflink Stream]
supports it, you can re-open an existing connection. This is the case for
[reflink tcp_connection] and [reflink unix_connection].

[warning
  Unfortunately, [asioreflink ssl__stream ssl::stream] does not support reconnection.
  If you are using [reflink tcp_ssl_connection] and you close
  the connection or encounter an error, you will have to destroy and re-create the connection object.
]

If you are using [reflink tcp_connection] or [reflink unix_connection], or any other stream supporting
reconnection:

* After calling [refmem connection close], you can re-open the connection later by calling
  [refmem connection connect] normally, even if the close operation failed.
* If your [refmem connection connect] operation failed, you can try opening it again
  by simply calling [refmem connection connect] again.
* If you connected your connection successfully but encountered a network problem in any subsequent operation,
  and you would like to re-establish connection, you should first call [refmem connection close] first, and
  then try opening the connection again by calling [refmem connection connect].

If your `Stream` type doesn't fulfill the __SocketStream__ type requirements,
then you can't use [refmem connection connect] or [refmem connection close], and you are thus
responsible for establishing the physical connection
and closing the underlying stream, if necessary. Some guidelines:

* After calling [refmem connection quit], you should close the underlying stream, if required. 
  You should then re-establish the physical connection on the stream, and call [refmem connection handshake] afterwards.
* If your [refmem connection handshake] operation failed, you are responsible for closing the underlying stream if required.
  You should then establish the physical connection again, and then call [refmem connection handshake].
* If you connected your connection successfully but encountered a network problem in any subsequent operation,
  and you would like to re-establish connection, you should call [refmem connection quit] first, then close and re-open
  the physical connection, and finally call [refmem connection handshake].

Note that __Self__ does not perform any built-in retry strategy, as different use cases have different requirements.
You can implement it as you best like with these tools. If you implemented your own and you would like to contribute it,
please create a PR in the GitHub repository.



TODO: set a heading for this.

[table
    [
        [Feature]
        [any_connection]
        [connection]
    ]
    [
        [Hostname resolution]
        [Performed by [refmem any_connection async_connect]]
        [Needs to be performed manually]
    ]
    [
        [Credentials]
        [
            [refmem connect_params username], [refmem connect_params password]
        ]
        [
            [refmem handshake_params username], [refmem handshake_params password]
        ]
    ]
    [
        [Database to use]
        [[refmem connect_params database]]
        [[refmem handshake_params database]]
    ]
    [
        [Setting TLS options]
        [
            [refmem any_connection_params ssl_ctx]
        ]
        [
            Pass a __ssl_context__ to [reflink tcp_ssl_connection]'s constructor.
        ]
    ]
    [
        [TLS negotiation]
        [[refmem connect_params ssl]. Ignored for if using UNIX sockets.]
        [[refmem handshake_params ssl]. Ignored if `Stream` is not TLS-enabled.]
    ]
    [
        [UNIX sockets]
        [Use a UNIX socket path in [refmem connect_params server_address]]
        [Use [reflink unix_connection] and pass a UNIX endpoint to [refmem connection connect]]
    ]
    [
        [Changing the initial size of the internal network buffer]
        [[refmem any_connection_params initial_buffer_size]]
        [Pass a [reflink buffer_params] instance to connection's constructor]
    ]
    [
        [Changing the network buffer size limit]
        [[refmem any_connection_params max_buffer_size]]
        [Not available: no limit on the network buffer size]
    ]
    [
        [Enabling multi-queries]
        [[refmem connect_params multi_queries]]
        [[refmem handshake_params multi_queries]]
    ]
    [
        [Changing the connection's character set]
        [[refmem any_connection async_set_character_set]]
        [Unavailable]
    ]
    [
        [Running pipelines]
        [[refmem any_connection async_run_pipeline]]
        [Unavailable]
    ]
    [
        [Access the underlying stream]
        [Unavailable]
        [[refmem connection stream]]
    ]
    [
        [Raw handshake and quit]
        [Unavailable]
        [[refmem connection handshake], [refmem connection quit]]
    ]
    [
        [Connection pooling]
        [[refmem connection_pool]]
        [Unavailable]
    ]
    [
        [Reconnection]
        [[refmem any_connection async_connect] can always be used]
        [Unavailable for [reflink tcp_ssl_connection] or after a cancellation]
    ]
    [
        [Including diagnostics in coroutine exceptions]
        [Enabled by default]
        [
            ```
            co_await conn.async_execute("SELECT 1", result, mysql::with_diagnostics);
            ```
        ]
    ]
]





[endsect]
