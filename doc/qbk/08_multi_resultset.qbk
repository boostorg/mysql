[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:multi_resultset Multi-resultset: stored procedures and multi-queries]

[heading Using stored procedures]

[mysqllink create-procedure.html Stored procedures] can be called using the `CALL` SQL statement.
You can use `CALL` statements from both text queries and prepared statements, in a similar way
to other SQL statements. Contrary to other statements, `CALL` may generate more than one resultset.

For example, given a stored procedure like this:

[multi_resultset_procedure]

You can call it using a prepared statement, with the usual syntax:

[multi_resultset_call]

MySQL responds here with two resultsets:

* A first resultset containing the employee matched by the `SELECT` query in the procedure.
* A second, empty resultset containing information about the `CALL` statement.

The [reflink results] class can store any number of resultsets.
It can be understood as a random-access collection of resultsets. To obtain the first resultset, we can write:

[multi_resultset_first_resultset]

[heading Determining the number of resultsets]

To know the number of resultsets to expect from a `CALL` statement, use these rules:

* For every statement that retrieves data (e.g. a `SELECT` statement), a resultset is sent.
  `SELECT ... INTO <variables>` statements don't cause a resultset to be sent.
* Statements that don't retrieve columns (e.g. `UPDATE`, `DELETE`) don't cause a resultset to be sent.
* An empty resultset containing information about the `CALL` statement execution is always sent last.

Some examples:

[!teletype]
```
    -- Calling proc1 produces only 1 resultset because it only contains statements that
    -- don't retrieve data
    CREATE PROCEDURE proc1(IN pin_order_id INT, IN pin_quantity INT)
    BEGIN
        START TRANSACTION;
        UPDATE orders SET quantity = pin_quantity WHERE id = pin_order_id;
        INSERT INTO audit_log (msg) VALUES ("Updated order...");
        COMMIT;
    END
```

[!teletype]
```
    -- Calling proc2 produces 3 resultsets: one for the orders SELECT, one for the
    -- line_items SELECT, and one for the CALL statement
    CREATE PROCEDURE proc2(IN pin_order_id INT)
    BEGIN
        START TRANSACTION READ ONLY;
        SELECT * FROM orders WHERE id = pin_order_id;
        SELECT * FROM line_items WHERE order_id = pin_order_id;
        COMMIT;
    END
```

[heading Output parameters]

You can get the value of `OUT` and `INOUT` parameters in stored procedures by using
prepared statement placeholders for them. When doing this, you will receive another resultset
with a single row containing all output parameter values. This resultset is located after
all resultsets generated by `SELECT`s, and before the final, empty resultset.
To simplify things, you can use [refmem results out_params] to retrieve them:

[multi_resultset_out_params]

[warning
    Due to a bug in MySQL, some `OUT` parameters are sent with wrong types.
    Concretely, string parameters are always sent as blobs, so you will have to
    use [refmem field_view as_blob] instead of [refmem field_view as_string].
]

[heading:multi_queries Semicolon-separated queries]

It is possible to run several semicolon-separated text queries in a single [refmem connection execute] call.
For security, this capability is disabled by default. Enabling it requires setting [refmem handshake_params multi_queries]
before connecting:

[multi_resultset_multi_queries]

You can access the resultsets produced by individual queries using [refmem results at] and [reflink2 results.operator_lb__rb_ results::operator[]].
These operations yield a [reflink resultset_view], which is a lighteight object pointing into memory owned by the `results`
object. You can take ownserhip of a `resultset_view` using the [reflink resultset] class. For example:

[multi_resultset_results_as_collection]

Note that statements like `DELIMITER` [*do not work] using this feature. This is because
`DELIMITER` is a pseudo-command for the `mysql` command line tool, not actual SQL.

[endsect]