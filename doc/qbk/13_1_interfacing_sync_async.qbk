[/
    Copyright (c) 2019-2025 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:interfacing_sync_async Interfacing sync and async code: a sync connection pool]
[nochunk]

As you may already know, we recommend using asynchronous functions over sync ones because
they are more versatile and scalable. Additionally, some classes like [reflink connection_pool]
do not offer a sync API.

If your entire application uses Asio, you can use async functions everywhere
as explained in the tutorials. However, some legacy applications are inherently synchronous,
and might need to call asynchronous code and wait for it synchronously.

This section explains how to handle these cases. We will build a synchronous
function that, given the ID of an employee, returns their name.
It will use [reflink connection_pool] and `asio::cancel_after`, which
can only be accessed through asynchronous functions.




[heading The asio::use_future completion token]

[asioreflink use_future use_future] is a [link mysql.tutorial_error_handling.completion_token completion token]
that does what we want: it launches an asynchronous operation and returns a `std::future` that
will complete when the task finishes.

With this knowledge, we can write a first version of our function:

```
// Gets an employee's name given their ID, using a connection pool. This is a sync function.
std::optional<employee> get_employee_by_id(mysql::connection_pool& pool, std::int64_t id)
{
    // TODO: with_patams
    // Get a connection from the pool. This will launch the operation, but won't wait for it
    std::future<mysql::pooled_connection> fut = pool.async_get_connection(asio::use_future);

    // Block the current thread until the operation completes.
    // As we will explain later, you need a thread running your execution context for this to complete
    mysql::pooled_connection conn = fut.get();

    // There is an execute sync function, so we can use this
    mysql::static_results<employee> r;
    conn->execute("SELECT first_name, last_name, salary FROM employee", r);

    // Done
    return r.rows().empty() ? std::nullopt : r.rows()[0];
}
```


For this to work, we need a thread that runs the execution context (event loop).
This is, calling `get()` on the future doesn't run the event loop.
Also note that our function will be called from a thread different to the
one running the execution context, so we need to make our pool thread-safe:


```
// Initialization code - run this once at program startup

// Execution context, required to run all async operations.
// This is equivalent to asio::io_context plus a thread calling run()
asio::thread_pool ctx (1);

// Create the connection pool
mysql::pool_params params;
params.server_address.emplace_host_and_port(server_hostname);
params.username = username;
params.password = password;
params.database = "boost_mysql_examples";
params.thread_safe = true; // allow initiating async_get_connection from any thread
mysql::connection_pool pool (ctx, std::move(params));
pool.async_run(asio::detached);
```




[heading Adding timeouts]

As you might know, [refmemunq connection_pool async_get_connection] may block indefinitely,
so we should use [asioreflink cancel_after cancel_after] to set a timeout. We might be tempted to do this:

```
std::optional<employee> get_employee_by_id(mysql::connection_pool& pool, std::int64_t id)
{
    using std::chrono_literals;

    // Do NOT do this!! This is a race condition!!
    auto fut = pool.async_get_connection(asio::cancel_after(10s, asio::use_future));

    // ...
}
```

It might not be obvious, but this is a data race. `asio::cancel_after` creates a timer under the hood.
This timer is shared between the thread calling `async_get_connection` and the one running the execution context.
The race condition goes like this:

* The thread calling `async_get_connection` sets up the timer required by `asio::cancel_after`.
* In parallel, the thread running the execution context sees that there is a healthy connection
  and completes the `async_get_connection` operation. As part of this, the timer is cancelled.
  Thus, the timer is accessed concurrently without protection.

Note that this happens even if the pool is thread-safe because the timer is not part of the pool.

To work this around, we can use a [@boost:/doc/html/boost_asio/overview/core/strands.html strand],
Asio's mechanism to protect against data races. We will create a strand, then enter it and use it
to run `async_get_connection`. This is a chain of asynchronous operations, so we can use
a [asioreflink deferred deferred] chain to implement it:

```
std::optional<employee> get_employee_by_id(mysql::connection_pool& pool, std::int64_t id)
{
    using std::chrono_literals;

    // Create a strand for this operation. Strands require an underlying
    // executor. Use the pool's executor, which points to the thread_pool we created.
    auto strand = asio::make_strand(pool.get_executor());

    // First enter the strand with asio::dispatch, then call async_get_connection through the strand.
    // asio::dispatch + asio::bind_executor is Asio's standard way to "run a function in an executor"
    std::future<mysql::pooled_connection> fut = asio::dispatch(
        // bind_executor binds an executor to a completion token.
        // deferred creates an async chain
        asio::bind_executor(
            strand,
            asio::deferred([] {
                // This function will be called when we're in the strand
                return async_get_connection(
                    asio::cancel_after(10s, asio::bind_executor(strand, asio::deferred))
                );
            })
        )
    )(asio::use_future); // Initiate the chain and convert it into a future

    // ...
}
```

Don't worry if this looks intimidating. Let's break this down into pieces:

* A strand is a compliant Asio executor. This means that it can be used with `asio::dispatch` and similar functions.
* [asioreflink dispatch dispatch] executes a function using the completion token bound to that function.
* [asioreflink bind_executor bind_executor] binds an executor to a completion token. Here, we're binding
  the strand to a deferred completion chain. This means that `dispatch` will use the strand to run its work.
* When passing [asioreflink deferred deferred] to an async operation, like `dispatch`, it returns a packaged
  async operation. We can call the operation with any completion token to initiate it. Here, we use `asio::use_future`
  to transform the operation into a future. If we were in a C++20 coroutine, we could co_await the object, too.
* The function passed to `deferred` will be executed when the first operation completes. This is, the function
  will be run within the strand. This is similar to JavaScript promise chains.
* If we return a deferred object from the function, the asynchronous operation will be executed as part of
  the deferred chain. Our next operation is `async_get_connection`.
* We use `bind_executor` with `asio::deferred` to make all handlers go through the strand, effectively protecting
  our timer.
* The future will complete once the entire chain finishes.




[heading Refactoring to use C++20 coroutines]

Deferred compositions can be used even in C++11, but they can get messy pretty fast.
Reasoning about their thread safety is non-trivial, either.

If you're in C++20 or above, a cleaner approach is to encapsulate all operations
involving networking into a coroutine:


```
// Gets an employee's name given their ID, using a connection pool. This is a sync function.
std::optional<employee> get_employee_by_id(mysql::connection_pool& pool, std::int64_t id)
{
    // Spawn a coroutine in the pool's executor - that is, in the thread_pool with one thread.
    // Since the pool has only one thread, and all code in the coroutine runs within that thread,
    // there is no need for a strand here.
    // co_spawn is an async operation, and can be used with asio::use_future
    return asio::co_spawn(
        pool.get_executor(),
        [&pool, id] () -> asio::awaitable<std::optional<employee>> {
            // Get a connection from the pool
            auto conn = co_await async_get_connection(asio::cancel_after(30s));

            // Execute
            mysql::static_results<employee> r;
            co_await conn->async_execute("SELECT first_name, last_name, salary FROM employee", r, asio::cancel_after(30s));

            // Done
            co_return r.rows().empty() ? std::nullopt : r.rows()[0];
        },
        asio::use_future
    ).get();
}
```

We're keeping all interactions with the `connection_pool` within coroutines,
so we don't need to make it thread-safe anymore. We can also encapsulate all
database access code into a class. With these changes, we have:


--- TODO ---

If you're in C++ < 20, you can use asio::spawn, or imitate the behavior of co_spawn + use_future manually using callbacks (do we show this, too?)


[endsect]
