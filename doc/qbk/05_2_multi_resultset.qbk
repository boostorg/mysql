[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:multi_resultset Stored procedures (multi-resultset)]

[heading Using stored procedures]

[mysqllink create-procedure.html Stored procedures] cal be called using the `CALL` SQL statement.
You can use `CALL` statements from both text queries and prepared statements, in a similar way
to other SQL statements.

Stored procedures can generate more than one resultset. To use them, you must
enable the [refmem handshake_params multi_results] option before you connect to the server:

```
    handshake_params params (
        "example_user",
        "example_password",
        "boost_mysql_integtests" // DB
    );
    
    // This line enables a protocol feature to be able to retrieve several results.
    // Without this line, you will get a sp_badselect error
    params.set_multi_results(true);

    // Connect normally
    conn.connect(endpoint, params);
```

Now, given a stored procedure like this:

```
    results result;
    conn.query(R"(
        CREATE PROCEDURE get_orders(IN order_id INT)
        BEGIN
            SELECT * FROM orders WHERE id = order_id;
        END
    )", result);
```

You can call it using a prepared statement, with the usual syntax:

```
    // The procedure parameter, order_id, will likely be obtained from an untrusted source,
    // so we will use a prepared statement
    statement get_orders_stmt = conn.prepare_statement("CALL (?)");

    // Obtain the parameters required to call the statement, e.g. from a file or HTTP message
    std::int64_t order_id = get_order_id();

    // Call the statement
    results result;
    conn.execute_statement(get_orders_stmt, std::make_tuple(order_id), result);
```

MySQL responds here with two resultsets:

* A first resultset containing the order matched by the `SELECT` query in the procedure.
* A second, empty resultset containing information about the `CALL` statement.

The [reflink results] class can store any number of resultsets.
It can be understood as a random-access collection. To obtain the first resultset, we can write:

```
    rows_view matched_orders = result.at(0).rows();
    // Use matched_orders as required
```

[heading Determining the number of resultsets]

To know the number of resultsets to expect from a `CALL` statement, use these rules:

* For every statement that retrieves data (e.g. a `SELECT` statement), a resultset is sent.
  `SELECT ... INTO <variables>` statements don't cause a resultset to be sent.
* Statements that don't retrieve columns (e.g. `UPDATE`, `DELETE`) don't cause a resultset to be sent.
* An empty resultset containing information about the `CALL` statement execution is always sent last.

Some examples:

```
    -- Calling proc1 produces only 1 resultset because it only contains statements that
    -- don't retrieve data
    CREATE PROCEDURE proc1(IN pin_order_id INT, IN pin_quantity INT)
    BEGIN
        START TRANSACTION;
        UPDATE orders SET quantity = pin_quantity WHERE id = pin_order_id;
        INSERT INTO audit_log (msg) VALUES ("Updated order...");
        COMMIT;
    END

    -- Calling proc2 produces 3 resultsets: one for the orders SELECT, one for the
    -- line_items SELECT, and one for the CALL statement
    CREATE PROCEDURE proc2(IN pin_order_id INT)
    BEGIN
        START TRANSACTION READ ONLY;
        SELECT * FROM orders WHERE id = pin_order_id;
        SELECT * FROM line_items WHERE order_id = pin_order_id;
        COMMIT;
    END
```

[heading Output parameters]

You can get the value of `OUT` and `INOUT` parameters in stored procedures by using
prepared statement placeholders for them. When doing this, you will receive another resultset
with a single row containing the output parameter values. This resultset is located after
all resultsets generated by `SELECT`s, and before the final, empty resultset.
To simplify things, you can use [refmem results out_params] to retrieve them:

```
    // Setup the stored procedure
    results result;
    conn.query(R"(
        CREATE PROCEDURE create_order(IN pin_user_id INT, OUT pout_order_id)
        BEGIN
            START TRANSACTION;
            INSERT INTO orders (user_id) VALUES (pin_user_id);
            SET pout_order_id = LAST_INSERT_ID();
            INSERT INTO audit_log (msg) VALUES ("Created order for user...");
            COMMIT;
        END
    )", result);

    // To retrieve output parameters, you must use prepared statements. Text queries don't support this
    // We specify placeholders for both IN and OUT parameters
    statement stmt = conn.prepare_statement("CALL create_order(?, ?)");

    // When executing the statement, we provide an actual value for the IN parameter,
    // and a dummy value for the OUT parameter. This value will be ignored, but it's required by the protocol
    std::int64_t user_id = get_current_user_id();
    conn.execute_statement(stmt, std::make_tuple(user_id, nullptr), result);

    // Retrieve output parameters. This row_view has an element per
    // OUT or INOUT parameter that used a ? placeholder
    row_view output_params = result.out_params();
    std::int64_t new_order_id = output_params.at(0);
```

[heading Using results as a collection]

The [reflink results] class is actually a random-access collection of resultsets.
Iterating or indexing a `results` object yields a [reflink resultset_view] that points
to the original `results`. You can take ownership of a single element using the [reflink resultset] class.

[heading:multi_queries Semicolon-separated queries]

It is possible to run several semicolon-separated text queries in a single [refmem connection query] call.
For security, this capability is disabled by default. Enabling it requires setting [refmem handshake_params multi_queries]
before connecting:

```
    handshake_params params (
        "example_user",
        "example_password",
        "boost_mysql_integtests" // DB
    );
    
    // Allows running multiple semicolon-separated in a single call
    params.set_multi_queries(true);

    // Connect normally
    conn.connect(endpoint, params);

    // Run queries
    results result;
    conn.query(R"(
        CREATE TEMPORARY TABLE products (
            id VARCHAR(50) PRIMARY KEY,
            description VARCHAR(256)
        );
        INSERT INTO products VALUES ('PTT', 'Potatoes');
        SELECT COUNT(*) FROM products;
    )", result);

    // This will result in three resultsets, one per query.
    // The insert is the 2nd resultset:
    std::int64_t potatoes_id = results.at(1).last_insert_id();

    // The SELECT is the third one. Read this as "access the (0, 0) element of the 3rd resultset"
    std::int64_t num_products = result.at(2).rows().at(0).at(0).as_int64();
```

Note that statements like `DELIMITER` [*do not work] using this feature. This is because
`DELIMITER` is a special command for the `mysql` command line tool, and is never sent to the server.

[endsect]