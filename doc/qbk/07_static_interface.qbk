[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:static_interface The static interface]
[nochunk]

--> TODO: review this. Take multifn & multiresult out of here

To use the static interface, we must first define a data structure that describes the shape of
your rows. We recommend using [@boost:/libs/describe/index.html Boost.Describe] for this.
We define a plain `struct` with the fields returned by your our and annotate it with
`BOOST_DESCRIBE_STRUCT` to enable reflection on it.

For example, given the following table definition and query:

```
    const char* table_definition = R"%(
        CREATE TEMPORARY TABLE posts (
            id INT PRIMARY KEY AUTO_INCREMENT,
            title VARCHAR (256) DEFAULT "",
            body TEXT DEFAULT ""
        )
    )%";
    const char* query = "SELECT id, title, body FROM posts";
```

We can define our row type like this:

```
    struct post
    {
        int id;
        std::string title;
        std::string body;
    };

    // Add reflection capabilities to post
    BOOST_DESCRIBE_STRUCT(post, (), (id, title, body));
```

To run the query, we can write:

```
    static_results<post> result;
    conn.execute(query, result);

    for (const post& p : result.rows())
    {
        // Process the post as required
        std::cout << "Title: " << p.title << "\n" << p.body << std::endl;
    }
```

Columns in the query are matched to fields in the struct by name.
If a struct field cannot be matched to any query column, an error is issued.
Extra columns in the query are ignored.

If your query contains columns with names that don't qualify as C++ identifiers,
you can use SQL aliases. For example:

```
    struct statistics
    {
        std::string company;
        std::int64_t average;
        std::int64_t max_value;
    };
    BOOST_DESCRIBE_STRUCT(statistics, (), (average, max_value));

    static_results<statistics> result;
    conn.execute(R"%(
        SELECT
            AVG(salary) AS average,
            MAX(salary) AS max_value,
            company_id AS company
        FROM employees
        GROUP BY company_id
    )%", result);
```

You can also use `std::tuple`s as row types. This can be handy for simple queries:

```
    static_results<std::tuple<std::int64_t>> result;
    conn.execute("SELECT COUNT(*) FROM posts", result);
    std::cout << "Number of posts: " << std::get<0>(result.rows()[0]) << std::endl;
```

Fields in tuples are matched to query columns by order. The query must return as many
columns as fields the tuple has, at least. Any extra trailing columns in the query are ignored.

[heading Metadata checking]

The static interface will try to validate as soon as possible that the provided row type 
is compatible with the schema returned by the server. This process is known as [*metadata checking],
and is performed before reading any data.

* [*Type compatibility]: the C++ type must be able to represent any value that the MySQL type can represent.
  For example, `std::int32_t` is compatible with `TINYINT` (1 byte integer), but not with `BIGINT` (8 byte integer).
  For a full list of allowable field types, [link mysql.static_interface.static_type_mappings refer to this table].
* [*Nullability]: if MySQL reports that a column can be `NULL`, your type must account for it. You can use
  `std::optional` or `boost::optional` for columns that may be `NULL`.

For example:

```
    struct post
    {
        int id;
        std::string title;
        std::optional<std::string> body;
    };
    BOOST_DESCRIBE_STRUCT(post, (), (id, title, body));
    
    // When retrieving rows, post::body::has_value() == false
    // if body is NULL in the database
```

You can also use [reflink non_null] to tell the static interface to disable
the nullability check for a certain field. This can be handy when using
stored procedures, since you may have more knowledge about nullability than MySQL.
For a usage example, see [link mysql.examples.stored_procedures_cpp14].


[heading Type mapping reference]

[table:static_type_mappings
    [
        [C++ type]
        [Compatible with...]
    ]
    [
        [`std::int8_t`]
        [
            __TINYINT__
        ]
    ]
    [
        [`std::uint8_t`]
        [
            __TINYINT__ `UNSIGNED`
        ]
    ]
    [
        [`std::int16_t`]
        [
            __TINYINT__[br]
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ [br]
            __YEAR__
        ]
    ]
    [
        [`std::uint16_t`]
        [
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ `UNSIGNED` [br]
            __YEAR__
        ]
    ]
    [
        [`std::int32_t`]
        [
            __TINYINT__, __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__, __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__, __MEDIUMINT__ `UNSIGNED`[br]
            __INT__[br]
            __YEAR__
        ]
    ]
    [
        [`std::uint32_t`]
        [
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__ `UNSIGNED`[br]
            __INT__ `UNSIGNED`[br]
            __YEAR__
        ]
    ]
    [
        [`std::int64_t`]
        [
            __TINYINT__,  __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__, __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__, __MEDIUMINT__ `UNSIGNED`[br]
            __INT__, __INT__ `UNSIGNED`[br]
            __BIGINT__[br]
            __YEAR__
        ]
    ]
    [
        [`std::uint64_t`]
        [
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__ `UNSIGNED`[br]
            __INT__ `UNSIGNED`[br]
            __BIGINT__ `UNSIGNED`[br]
            __YEAR__[br]
            __BIT__
        ]
    ]
    [
        [`bool`]
        [
            `BOOL` or `BOOLEAN` (alias for __TINYINT__).
        ]
    ]
    [
        [`float`]
        [
            __FLOAT__
        ]
    ]
    [
        [`double`]
        [
            __FLOAT__, __DOUBLE__[br]
        ]
    ]
    [
        [`date`]
        [
            __DATE__
        ]
    ]
    [
        [`datetime`]
        [
            __DATETIME__, __TIMESTAMP__
        ]
    ]
    [
        [`time`]
        [
            __TIME__
        ]
    ]
    [
        [`std::basic_string<char, Traits, Allocator>`]
        [
            __CHAR__, __VARCHAR__, __TEXT__[br]
            __ENUM__, __SET__[br]
            __JSON__[br]
            __DECIMAL__/__NUMERIC__
        ]
    ]
    [
        [`std::basic_vector<unsigned char, Allocator>`]
        [
            __BINARY__, __VARBINARY__, __BLOB__[br]
            __GEOMETRY__
        ]
    ]
    [
        [`std::optional<T>`]
        [
            Any type compatible with `T`
        ]
    ]
    [
        [`boost::optional<T>`]
        [
            Any type compatible with `T`
        ]
    ]
    [
        [[reflink2 non_null `non_null<T>`]]
        [
            Any type compatible with `T`
        ]
    ]
]

[endsect]
