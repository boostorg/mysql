[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:connection_pool Connection pools]
[nochunk]

Establishing a MySQL session is expensive. If you create, connect and destroy a connection
every time you need to execute a query, your application performance may degrade.
Connection pooling can boost your performance by maintaining long-lived
sessions that you can reuse.

[note
    This feature is experimental. Its API may change in subsequent releases.
]

This is how you can create a pool of connections:

[connection_pool_create]

[reflink connection_pool] is an I/O object that manages connections.
It can be constructed from an executor or execution context (like all I/O objects)
and a [reflink pool_params] object.

[refmem connection_pool async_run] must be called exactly once per pool.
This function takes care of actually keeping connections healthy.

We're now ready to obtain connections using [refmem connection_pool async_get_connection].
We will use C++20 coroutines to make async code simpler:

[connection_pool_get_connection]

By default, [refmem connection_pool async_run] will run forever. When
your application exits, you will want to stop it using [refmem connection_pool cancel].
This is typical in signal handlers, to guarantee a clean shutdown.

Note that pooling works only with [reflink any_connection].

[note
    `connection_pool` exposes async functions only. This has to do
    with efficiency and oddities in Boost.Asio executor model.
    If you need a sync API, please visit [link mysql.connection_pool.sync this section].
]



[section Pool size]

Pools start with a fixed initial size, and will be dynamically resized up
to an upper limit if required. You can configure these sizes using
[refmem pool_params initial_size] and [refmem pool_params max_size].

The resizing algorithm works like this:
* When the pool is created, [refmem pool_params initial_size] number of connections are created and
  connected (by default, `initial_size` is 1).
* If a connection is requested, but all available connections are in use, a
  new one is created, until `max_size` is reached. 
* If a connection is requested, and there are `max_size` connections in use,
  [refmem connection_pool async_get_connection] waits for a connection to become available,
  up to a certain period of time. After this period of time, if no connection is available, the operation fails.
* Once created, connections never get deallocated.

By default, [refmem pool_params max_size] is 151, which is
MySQL's default value for the [mysqllink server-system-variables.html#sysvar_max_connections `max_connections`]
system variable, controlling the maximum number of concurrent connections allowed by the server.

[note
    Before increasing [refmem pool_params max_size], make sure to also increase
    the value of `max_connections` in the server. Otherwise, your connections
    will be rejected by the connection limit.
]

This is how you configure pool sizes:

[connection_pool_configure_size]

[endsect]


[section Session state]

MySQL connections hold state. You change session state when you prepare statements,
create temporary tables, start transactions, or set session variables. When using
pooled connections, session state can be problematic: if not reset properly,
state from a previous operation may affect subsequent ones.

After you return a connection to the pool, it uses [refmem any_connection async_reset_connection]
to wipe session state before the connection can be obtained again. This will deallocate
prepared statements, rollback uncommited transactions and clear variables.
In particular, you don't need to call [refmem any_connection async_close_statement]
to deallocate statements.

Resetting a connection is cheap but entails a cost (a roundtrip to the server).
If you've used a connection and are sure that you didn't mutate session state,
you can use [refmem pooled_connection return_without_reset] to skip resetting.
For instance:

[connection_pool_return_without_reset]

Connection reset happens in the background, after the connection has been
returned, so it does not affect latency. If you're not sure if an operation
affects state or not, assume it does.

[endsect]

[section Character sets]

[warning
    The current implementation, together with unintuitive MySQL defaults,
    can yield to surprising behavior.
]

When using pooled connections, [*all connections use the server's default character set].
This is because [refmem any_connection async_reset_connection] discards the character set
options specified during connection establishment.

You can obtain this character set by running:

```
SELECT @@global.character_set_client, @@global.character_set_connection, @@global.character_set_results;
```

MySQL v8.0+ defaults to `utf8mb4`, but older MySQL and MariaDB servers default to
`latin1`, which is not usually what you want. Issue a __SET_NAMES__ statement
after you get a connection to change it. [@https://github.com/boostorg/mysql/issues/187 This issue]
tracks solving this limitation.

[endsect]

[section Connection lifecycle]

The behavior already explained can be summarized using a state model like the following:

[$mysql/images/pooled_connection_lifecycle.svg [align center]]

In short:

* When a connection is created, it goes into the `pending_connect` state.
* Connection establishment is attempted. If it succeeds, the connection becomes `iddle`.
  Otherwise, it stays `pending_connect`, and another attempt will be performed
  after [refmem pool_params retry_interval] has ellapsed.
* `iddle` connections can be retrieved by [refmem connection_pool async_get_connection],
  and they become `in_use`.
* If a connection is returned by [reflink pooled_connection return_without_reset],
  it becomes `iddle` again.
* If a connection is returned by [reflink pooled_connection]'s destructor, it becomes
  `pending_reset`.
* [refmem any_connection async_reset_connection] is applied to `pending_reset` connections.
  On success, they become `iddle` again. Otherwise, they become `pending_connect` and will
  be reconnected.
* If a connection stays `iddle` for [refmem pool_params ping_interval], it becomes `pending_ping`.
  At this point, the connection is probed. If it's alive, it will return to being `iddle`.
  Otherwise, it becomes `pending_connect` to be reconnected. Pings can be disabled by
  setting [refmem pool_params ping_interval] to zero.

[endsect]

[section Thread-safety and executors]

By default, [reflink connection_pool] is [*NOT thread-safe], but it can
be easily made thread-safe by using:

[connection_pool_thread_safe]

This works by using strands. Recall that a [asioreflink strand] is Asio's method to enable concurrency
without explicit locking. A strand is an executor that wraps another executor.
All handlers dispatched through a strand will be serialized: no two handlers
will be run in parallel, which avoids data races.

We're passing a [reflink pool_executor_params] instance to the pool's
constructor, which contains two executors:

* [refmem pool_executor_params pool_executor] is used to run [refmem connection_pool async_run]
  and [refmem connection_pool async_get_connection] intermediate handlers. By using
  [refmem pool_executor_params thread_safe], a strand is created, and all these handlers
  will be serialized.
* [refmem pool_executor_params connection_executor] is used to construct connections.
  By default, this won't be wrapped in any strand, and inividual connections will not be thread-safe.






[endsect]



* When to use

* mention TLS? benchmarks







* Transport types and SSL.
  * The connection pool uses `any_connection`, so it can be used with TCP, TCP with SSL and UNIX sockets.
    Just set `server_address` and `ssl_mode` appropriately.
  * By default, TCP connections use SSL. An SSL context is created internally, but can be overriden
    by using `ssl_context`. Can be used to set SSL options.
  

[section:sync Implementing sync functions]

* Has only async functions (async_run and async_get_connection)
* Internally async functions must be used to provide timeouts and efficiency
* Due to oddities in the executor model, there's no way for the library to expose
  sync functions that work for any executor.
* But if you're using `io_context` or `thread_pool`, super easy to do so:

TODO: thread-safety
```


```


[endsect]

[endsect]