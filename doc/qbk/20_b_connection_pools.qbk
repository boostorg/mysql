[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:connection_pool Connection pools]
[nochunk]

Establishing a MySQL session is expensive. If you create, connect and destroy a connection
every time you need to execute a query, your application performance may degrade.
Connection pooling can boost your performance by maintaining long-lived
sessions that you can reuse.

[note
    This feature is experimental. Its API may change in subsequent releases.
]

This is how you can create a pool of connections:

[connection_pool_create]

[reflink connection_pool] is an I/O object that manages connections.
It can be constructed from an executor or execution context (like all I/O objects)
and a [reflink pool_params] object.

[refmem connection_pool async_run] must be called exactly once per pool.
This function takes care of actually keeping connections healthy.

We're now ready to obtain connections using [refmem connection_pool async_get_connection].
We will use C++20 coroutines to make async code simpler:

[connection_pool_get_connection]

By default, [refmem connection_pool async_run] will run forever. When
your application exits, you will want to stop it using [refmem connection_pool cancel].
This is typical in signal handlers, to guarantee a clean shutdown.

Note that pooling works only with [reflink any_connection].

[note
    `connection_pool` exposes async functions only. This has to do
    with efficiency and oddities in Boost.Asio executor model.
    If you need a sync API, please visit [link mysql.connection_pool.sync this section].
]



[section Pool size]

Pools start with a fixed initial size, and will be dynamically resized up
to an upper limit if required. You can configure these sizes using
[refmem pool_params initial_size] and [refmem pool_params max_size].

The resizing algorithm works like this:
* When the pool is created, [refmem pool_params initial_size] number of connections are created and
  connected (by default, `initial_size` is 1).
* If a connection is requested, but all available connections are in use, a
  new one is created, until `max_size` is reached. 
* If a connection is requested, and there are `max_size` connections in use,
  [refmem connection_pool async_get_connection] waits for a connection to become available,
  up to a certain period of time. After this period of time, if no connection is available, the operation fails.
* Once created, connections never get deallocated.

By default, [refmem pool_params max_size] is 151, which is
MySQL's default value for the [mysqllink server-system-variables.html#sysvar_max_connections `max_connections`]
system variable, controlling the maximum number of concurrent connections allowed by the server.

[note
    Before increasing [refmem pool_params max_size], make sure to also increase
    the value of `max_connections` in the server. Otherwise, your connections
    will be rejected by the connection limit.
]

This is how you configure pool sizes:

[connection_pool_configure_size]

[endsect]


[section Session state]

MySQL connections hold state. You change session state when you prepare statements,
create temporary tables, start transactions, or set session variables. When using
pooled connections, session state can be problematic: if not reset properly,
state from a previous operation may affect subsequent ones.

After you return a connection to the pool, it uses [refmem any_connection async_reset_connection]
to wipe session state before the connection can be obtained again. This will deallocate
prepared statements, rollback uncommited transactions and clear variables.

Resetting a connection is cheap but entails a cost (a roundtrip to the server).
If you've used a connection and are sure that you didn't mutate session state,
you can use [refmem pooled_connection return_without_reset] to skip resetting.
For instance:

[connection_pool_return_without_reset]

Connection reset happens in the background, after the connection has been
returned, so it does not affect latency. If you're not sure if an operation
affects state or not, assume it does.

[endsect]

[section Character sets]

[warning
    The current implementation, together with unintuitive MySQL defaults,
    can yield to surprising behavior.
]

When using pooled connections, [*all connections use the server's default character set].
This is because [refmem any_connection async_reset_connection] discards the character set
options specified during connection establishment.

You can obtain this character set by running:

```
SELECT @@global.character_set_client, @@global.character_set_connection, @@global.character_set_results;
```

MySQL v8.0+ defaults to `utf8mb4`, but older MySQL and MariaDB servers default to
`latin1`, which is not usually what you want. Issue a __SET_NAMES__ statement
after you get a connection to change it. [@https://github.com/boostorg/mysql/issues/187 This issue]
tracks solving this limitation.

[endsect]

[warning
    Pooled connections will always use the server's default 
    Resetting a session will restore the connection character set to the server's
    default. For MySQL 5.7.x, this is usually `latin1`, which is almost never what you want.

]

  * State, character set, and time_zone: `reset_connection` clears session variables,
    including any character set and time_zone settings. TBC: how do we do this
  * Prepared statements and `reset_connection`: `reset_connection` will clear any
    prepared statement. This means you need to prepare them dynamically, and that you
    don't need to call `async_close_statement` - handled for you.

[endsect]

* When to use

* mention TLS? benchmarks





  

* The connection lifecycle. Connections managed by the pool follow this state model:
  * They're created, initially or because no connections were available.
  * They're connected.
  * If connect fails, we wait some time, then try to connect again. This period is
    given by `retry_interval`.
  * After successful connection, they become iddle. At this point, they're ready to get picked by `async_get_connection`.
  * When they're picked, they become in use.
  * When you return them, if you marked them as `reset=false`, they become iddle.
  * If `reset=true`, they become pending reset.
  * After they are reset, they become iddle again.
  * If a connection stays iddle for a very long time, by default, the pool will run a healthcheck
    (`async_ping`). After the ping period ellapses, they become pending ping, pinged, and back to iddle.
    This prevents connections from closing, and helps detect network problems to attempt reconnections.
    Ping period (`ping_interval`) is 1h by default, and can be disabled by setting it to 0.
  * If ping or reset fail, the connection is marked as failed, and the reconnect loop starts again.

* Thread-safety. By default, `connection_pool` is thread-safe. You can use it in a MT context,
  share a single instance between threads, without race conditions. How this works:
  * The pool will internally create an `asio::strand` around the executor you pass to the pool's ctor.
  * All functions are either inherently thread-safe (e.g. use `std::amotic<T>`), or will use
    `asio::post`/`asio::dispatch` to ensure that all the intermediate handlers are run in a thread-safe manner.
  * Individual connections returned by the pool are *NOT* thread-safe. You're responsible for
    not incurring in race-conditions with them. They are constructed using the executor you pass.
  * This thread-safety mechanism can be disabled using `enable_thread_safety=false`. It's enabled by
    default. By disabling it, you're responsible for keeping thread-safety. Can be used to increase
    performance or to build custom thread-safety mechanisms on top.

* Transport types and SSL.
  * The connection pool uses `any_connection`, so it can be used with TCP, TCP with SSL and UNIX sockets.
    Just set `server_address` and `ssl_mode` appropriately.
  * By default, TCP connections use SSL. An SSL context is created internally, but can be overriden
    by using `ssl_context`. Can be used to set SSL options.
  

[section:sync Implementing sync functions]

* Has only async functions (async_run and async_get_connection)
* Internally async functions must be used to provide timeouts and efficiency
* Due to oddities in the executor model, there's no way for the library to expose
  sync functions that work for any executor.
* But if you're using `io_context` or `thread_pool`, super easy to do so:

TODO: thread-safety
```


```


[endsect]

[endsect]