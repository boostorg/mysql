[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:connection_pool Connection pools]
[nochunk]

Establishing a MySQL session is expensive. If you create, connect and destroy a connection
every time you need to execute a query, your application performance may degrade.
Connection pooling can boost your performance by maintaining long-lived
sessions that you can reuse.

[note
    This feature is experimental. Its API may change in subsequent releases.
]

This is how you can create a pool of connections:

[connection_pool_create]

[reflink connection_pool] is an I/O object that manages connections.
It can be constructed from an execution context (like all I/O objects)
and a [reflink pool_params] object.

[refmem connection_pool async_run] must be called exactly once per pool.
This function takes care of actually keeping connections healthy.

We're now ready to obtain connections using [refmem connection_pool async_get_connection]:


```
    io_context ctx;

    pool_params params {
        host_and_port(my_server_hostname),
        my_username,
        my_password,
        my_database,
    };

    connection_pool pool (ctx, std::move(params));

    pool.async_run(asio::detached);

// ...

asio::awaitable<void> handle_request(
    connection_pool& pool
)
{
    // Get a connection. pooled_connection is a proxy to an any_connection object
    pooled_connection conn = pool.async_get_connection(asio::use_awaitable);

    // Use it as required
    results result;
    conn->async_execute("SELECT * FROM my_table", result, asio::use_awaitable);

    // Use the result to compose the response. When conn is destroyed,
    // the underlying connection is returned to the pool
}
```

* `pool_params` specifies configuration for the pool. This includes the server hostname,
  credentials, initial and max size, etc.
* The pool requires you calling `async_run`. This function takes care of connecting
  connections, sending keep alives, returning them, and any other cleanup tasks that
  happen behind the scenes. `async_run` must be called only once.
* You then call `async_get_connection`. This returns you a `pooled_connection` object.
  This is a proxy object to an `any_connection`. When it's destroyed, the underlying
  `any_connection` is returned to the pool.

* `connection_pool` only works with `any_connection`.
* `connection_pool` only has async functions, for performance (but see section on sync).
* mention TLS? benchmarks

* Cancelling: `async_run` will run forever, by default. If you want it to stop, call `cancel`:

```
connection_pool pool (ctx, std::move(params));
pool.async_run(asio::detached);

// wait until the program should exit, e.g. on SIGINT
// This will make async_run exit
pool.cancel();
```

In general, lifetimes are foolproof. `connection_pool`'s internals will be kept alive
until all `pooled_connection` s are destroyed and all async operations complete.
Destructor cancels.

* Pool sizes.
  * Two params control pool size: `initial_size` and `max_size`.
  * When the pool is created, `initial_size` number of connections are created and
    connected (by default 1).
  * If a connection is requested, but all available connections are in use, a
    new one is created, up to `max_size` (by default 151, which is MySQL's default value for `max_connections`).
  * If a connection is requested, and all available connections are in use, and there are `max_size`
    connections, then `async_get_connection` will wait for a connection to become available.
  * `async_get_connection` admits an optional timeout. If no connection is available after that timeout,
    the operation fails.
  * Once created, connections never get deallocated.

```
    pool_params params {
        // Hostname, username, password...
    };

    // Create 10 connections at startup
    params.initial_size = 10;

    // Increase upper limit. Note that you will need to adjust
    // your server configuration to allow more connections for this
    // setting to make sense (TODO: link) - otherwise your connections
    // will be stuck being rejected by the connection limit.
    params.max_size = 1000;
```

* Session state. MySQL connections hold state. You change session state when preparing statements,
  create temporary tables, start transactions, set session variables or lock tables.
  * When re-using connections, session state can be problematic: you get a connection,
    change some state, return it to the pool. When the connection is get again, if session
    state hasn't been reset, you may encounter unexpected results (leftovers from the previous logical operation).
  * The pool will use `any_connection::reset_connection`, to wipe session state. But this is configurable.
  * There are two ways to return a connection to the pool:
    * By default (`pooled_connection` destructor) will mark the connection as requiring a reset.
      After the connection is returned (in background), `reset_connection` will be used to wipe
      state before the connection can be re-used.
    * You can opt-out from this behavior by calling `pooled_connection::return_connection(false)`.
      Connections returned like this become iddle as they are returned - so you're responsible
      for not leaving any state behind.
  * Use case for `return_connection(false)`: read-only queries:

```
  auto conn = co_await pool.async_get_connection(asio::use_awaitable);
  conn->async_query("SELECT COUNT(*) FROM USERS", result);
  conn.return_connection(false);
```

  * State, character set, and time_zone: `reset_connection` clears session variables,
    including any character set and time_zone settings. TBC: how do we do this
  * Prepared statements and `reset_connection`: `reset_connection` will clear any
    prepared statement. This means you need to prepare them dynamically, and that you
    don't need to call `async_close_statement` - handled for you.
  

* The connection lifecycle. Connections managed by the pool follow this state model:
  * They're created, initially or because no connections were available.
  * They're connected.
  * If connect fails, we wait some time, then try to connect again. This period is
    given by `retry_interval`.
  * After successful connection, they become iddle. At this point, they're ready to get picked by `async_get_connection`.
  * When they're picked, they become in use.
  * When you return them, if you marked them as `reset=false`, they become iddle.
  * If `reset=true`, they become pending reset.
  * After they are reset, they become iddle again.
  * If a connection stays iddle for a very long time, by default, the pool will run a healthcheck
    (`async_ping`). After the ping period ellapses, they become pending ping, pinged, and back to iddle.
    This prevents connections from closing, and helps detect network problems to attempt reconnections.
    Ping period (`ping_interval`) is 1h by default, and can be disabled by setting it to 0.
  * If ping or reset fail, the connection is marked as failed, and the reconnect loop starts again.

* Thread-safety. By default, `connection_pool` is thread-safe. You can use it in a MT context,
  share a single instance between threads, without race conditions. How this works:
  * The pool will internally create an `asio::strand` around the executor you pass to the pool's ctor.
  * All functions are either inherently thread-safe (e.g. use `std::amotic<T>`), or will use
    `asio::post`/`asio::dispatch` to ensure that all the intermediate handlers are run in a thread-safe manner.
  * Individual connections returned by the pool are *NOT* thread-safe. You're responsible for
    not incurring in race-conditions with them. They are constructed using the executor you pass.
  * This thread-safety mechanism can be disabled using `enable_thread_safety=false`. It's enabled by
    default. By disabling it, you're responsible for keeping thread-safety. Can be used to increase
    performance or to build custom thread-safety mechanisms on top.

* Transport types and SSL.
  * The connection pool uses `any_connection`, so it can be used with TCP, TCP with SSL and UNIX sockets.
    Just set `server_address` and `ssl_mode` appropriately.
  * By default, TCP connections use SSL. An SSL context is created internally, but can be overriden
    by using `ssl_context`. Can be used to set SSL options.

[endsect]