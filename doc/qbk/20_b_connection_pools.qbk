[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:connection_pool Connection pools]
[nochunk]

Establishing a MySQL session is expensive. If you create, connect and destroy a connection
every time you need to execute a query, your application performance may degrade.
Connection pooling can boost your performance by maintaining long-lived
sessions that you can reuse.

[note
    This feature is experimental. Its API may change in subsequent releases.
]

This is how you can create a pool of connections:

[connection_pool_create]

[reflink connection_pool] is an I/O object that manages connections.
It can be constructed from an executor or execution context (like all I/O objects)
and a [reflink pool_params] object.

[refmem connection_pool async_run] must be called exactly once per pool.
This function takes care of actually keeping connections healthy.

We're now ready to obtain connections using [refmem connection_pool async_get_connection].
We will use C++20 coroutines to make async code simpler:

[connection_pool_get_connection]

By default, [refmem connection_pool async_run] will run forever. When
your application exits, you will want to stop it using [refmem connection_pool cancel].
This is typical in signal handlers, to guarantee a clean shutdown.

Note that pooling works only with [reflink any_connection].

[note
    `connection_pool` exposes async functions only. This has to do
    with efficiency and oddities in Boost.Asio executor model.
    If you need a sync API, please visit [link mysql.connection_pool.sync this section].
]



[section:size Pool size]

Pools start with a fixed initial size, and will be dynamically resized up
to an upper limit if required. You can configure these sizes using
[refmem pool_params initial_size] and [refmem pool_params max_size].

The resizing algorithm works like this:
* When the pool is created, [refmem pool_params initial_size] number of connections are created and
  connected (by default, `initial_size` is 1).
* If a connection is requested, but all available connections are in use, a
  new one is created, until `max_size` is reached. 
* If a connection is requested, and there are `max_size` connections in use,
  [refmem connection_pool async_get_connection] waits for a connection to become available,
  up to a certain period of time. After this period of time, if no connection is available, the operation fails.
* Once created, connections never get deallocated.

By default, [refmem pool_params max_size] is 151, which is
MySQL's default value for the [mysqllink server-system-variables.html#sysvar_max_connections `max_connections`]
system variable, controlling the maximum number of concurrent connections allowed by the server.

[note
    Before increasing [refmem pool_params max_size], make sure to also increase
    the value of `max_connections` in the server. Otherwise, your connections
    will be rejected by the connection limit.
]

This is how you configure pool sizes:

[connection_pool_configure_size]

[endsect]


* When to use

* mention TLS? benchmarks






* Session state. MySQL connections hold state. You change session state when preparing statements,
  create temporary tables, start transactions, set session variables or lock tables.
  * When re-using connections, session state can be problematic: you get a connection,
    change some state, return it to the pool. When the connection is get again, if session
    state hasn't been reset, you may encounter unexpected results (leftovers from the previous logical operation).
  * The pool will use `any_connection::reset_connection`, to wipe session state. But this is configurable.
  * There are two ways to return a connection to the pool:
    * By default (`pooled_connection` destructor) will mark the connection as requiring a reset.
      After the connection is returned (in background), `reset_connection` will be used to wipe
      state before the connection can be re-used.
    * You can opt-out from this behavior by calling `pooled_connection::return_connection(false)`.
      Connections returned like this become iddle as they are returned - so you're responsible
      for not leaving any state behind.
  * Use case for `return_connection(false)`: read-only queries:

```
  auto conn = co_await pool.async_get_connection(asio::use_awaitable);
  conn->async_query("SELECT COUNT(*) FROM USERS", result);
  conn.return_connection(false);
```

  * State, character set, and time_zone: `reset_connection` clears session variables,
    including any character set and time_zone settings. TBC: how do we do this
  * Prepared statements and `reset_connection`: `reset_connection` will clear any
    prepared statement. This means you need to prepare them dynamically, and that you
    don't need to call `async_close_statement` - handled for you.
  

* The connection lifecycle. Connections managed by the pool follow this state model:
  * They're created, initially or because no connections were available.
  * They're connected.
  * If connect fails, we wait some time, then try to connect again. This period is
    given by `retry_interval`.
  * After successful connection, they become iddle. At this point, they're ready to get picked by `async_get_connection`.
  * When they're picked, they become in use.
  * When you return them, if you marked them as `reset=false`, they become iddle.
  * If `reset=true`, they become pending reset.
  * After they are reset, they become iddle again.
  * If a connection stays iddle for a very long time, by default, the pool will run a healthcheck
    (`async_ping`). After the ping period ellapses, they become pending ping, pinged, and back to iddle.
    This prevents connections from closing, and helps detect network problems to attempt reconnections.
    Ping period (`ping_interval`) is 1h by default, and can be disabled by setting it to 0.
  * If ping or reset fail, the connection is marked as failed, and the reconnect loop starts again.

* Thread-safety. By default, `connection_pool` is thread-safe. You can use it in a MT context,
  share a single instance between threads, without race conditions. How this works:
  * The pool will internally create an `asio::strand` around the executor you pass to the pool's ctor.
  * All functions are either inherently thread-safe (e.g. use `std::amotic<T>`), or will use
    `asio::post`/`asio::dispatch` to ensure that all the intermediate handlers are run in a thread-safe manner.
  * Individual connections returned by the pool are *NOT* thread-safe. You're responsible for
    not incurring in race-conditions with them. They are constructed using the executor you pass.
  * This thread-safety mechanism can be disabled using `enable_thread_safety=false`. It's enabled by
    default. By disabling it, you're responsible for keeping thread-safety. Can be used to increase
    performance or to build custom thread-safety mechanisms on top.

* Transport types and SSL.
  * The connection pool uses `any_connection`, so it can be used with TCP, TCP with SSL and UNIX sockets.
    Just set `server_address` and `ssl_mode` appropriately.
  * By default, TCP connections use SSL. An SSL context is created internally, but can be overriden
    by using `ssl_context`. Can be used to set SSL options.
  

[section:sync Implementing sync functions]

* Has only async functions (async_run and async_get_connection)
* Internally async functions must be used to provide timeouts and efficiency
* Due to oddities in the executor model, there's no way for the library to expose
  sync functions that work for any executor.
* But if you're using `io_context` or `thread_pool`, super easy to do so:

TODO: thread-safety
```


```


[endsect]

[endsect]