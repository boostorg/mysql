[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:overview Overview]
[nochunk]


This section briefly explains the library main classes and functions, and how to use them.

[section:connection Connection objects]

[reflink connection] is the most important class in the library. A connection is an I/O object, templated on
a [reflink Stream] type. A `connection` contains an instance of that `Stream` type and additional state required
by the protocol. `connection`'s constructor takes the same arguments as the underlying `Stream` constructor.

The library defines some typedefs to make things less verbose. The most common one is [reflink tcp_ssl_connection].
In this case, `Stream` is `boost::asio::ssl::stream<boost::asio::ip::tcp::socket>`,
which can be constructed from a [asioreflink any_io_executor any_io_executor]
and a [asioreflink ssl__context ssl::context]:

[overview_connection]

Typedefs for other transports are also available. See [link mysql.other_streams this section] for more info.

[endsect]

[section Connection establishment]

The MySQL client/server protocol is session-oriented. Before anything else, you must perform session
establishment, usually by calling [refmem connection connect]. This function performs two actions:

* It establishes the "physical" connection, by calling `connect()` on the underlying `Stream`
  object. For a [reflink tcp_ssl_connection], this establishes the TCP connection.
* It performs the handshake with the MySQL server. This is part of the MySQL client/server
  protocol. It performs authentication, sets session parameters like the default database
  to use, and performs the TLS handshake, if required.

[refmem connection connect] takes two parameters, one for each of the above actions:

* The physical endpoint where the server is listening. For TCP streams, this is a
  `boost::asio::ip::tcp::endpoint`. For UNIX sockets, it's a `boost::asio::local::stream_protocol::endpoint`.
  For TCP, we can resolve a string hostname and port into an endpoint using a `resolver` object.
* [reflink handshake_params] to use for the handshake operation. This parameter doesn't depend on the `Stream`
  type. See [link mysql.connparams this section] for more info.

[overview_connect]

Note that [refmem connection connect] can only be used with socket-like streams. If your stream
is not a socket, you must use the lower-level [refmem connection handshake] function. Please
read [link mysql.other_streams.non_sockets this section] for more info.

[endsect]

[section:queries_stmts Text queries and prepared statements]

The two main ways to use a connection are text queries and prepared statements:

[table
    [
        [Feature]
        [Used for...]
        [Code]
    ]
    [
        [
            Text queries: [refmem connection query].
        ]
        [
            Simple queries, without parameters:

                * `"START TRANSACTION"`
                * `"SET NAMES utf8"`
                * `"SHOW TABLES"`
            
        ]
        [
            [overview_query_use_case]
        ]
    ]
    [
        [
            Prepared statements:[br]
            [refmem connection prepare_statement][br]
            [refmem connection execute_statement]
        ]
        [
            Queries with parameters unknown at compile-time.
        ]
        [
            [overview_statement_use_case]
        ]
    ]
]

When you execute a text query or a prepared statement, you get a `results` object, which will be the subject
of the next section. We will delve deeper into prepared statements [link mysql.overview.statements later].

[endsect]

[section Resultsets]

In MySQL, a ['resultset] referes to the results generated by a SQL query. The [reflink results] class
is an in-memory reprentation of a MySQL resultset. The following diagram shows an approximate representation
of what a resultset looks like:

[$mysql/images/resultset.svg [align center] [scale 125]]

We can see that a resultset is composed of three pieces of information:

* The actual rows generated by the SQL query: [refmem results rows]. We'll expand on this later.
* Metadata about the columns retrieved by the query: [refmem results meta]. See [link mysql.meta this section]
  for more info.
* Additional information about the query execution, like the number of affected rows ([refmem results affected_rows])
  or the number of warnings generated by the query ([refmem results warning_count]).

You can obtain a `results` object by executing a text query ([refmem connection query]) or a prepared statement
([refmem connection execute_statement]).

All SQL statements generate resultsets. Statements that generate no rows, like `INSERT`s, generate empty resultsets
(i.e. `result.rows().empty() == true`). The interface to execute `SELECT`s and `INSERT`s is the same.

[endsect]

[section Rows and fields]

We saw that [refmem results rows] returns a matrix-like data structure containing the rows
retrieved by SQL query. This library defines six data structures to represent MySQL data:

[variablelist
    [
        [[reflink field]]
        [The smallest unit of data. A single "cell" in a MySQL table. This is an owning, variant-like type.]
    ]
    [
        [[reflink field_view]]
        [Like `field`, but non-owning.]
    ]
    [
        [[reflink row]]
        [An owning, `vector`-like collection of fields.]
    ]
    [
        [[reflink row_view]]
        [Like `row`, but non-owning.]
    ]
    [
        [[reflink rows]]
        [An owning, matrix-like collection of fields. Represents several rows of the same size in an optimized way.]
    ]
    [
        [[reflink rows_view]]
        [Like `rows`, but non-owning.]
    ]
]

[refmem results rows] returns a [reflink rows_view] object. The memory for the rows is owned by the
`results` object. Indexing the returned view also returns view objects:

[overview_views]

Views behave similarly to `std::string_view`. You must make sure that you don't use a view after the
storage it points to has gone out of scope. In this case, you must not use any of the views after the
`results` object has gone out of scope.

As it happens with `std::string_view`, you can take ownership of a view using its owning counterpart:

[overview_taking_ownership]

[endsect]

[section:fields Using fields]

[reflink field] and [reflink field_view] are specialized variant-like types that can hold any type
you may find in a MySQL table. Once you obtain a field, you can access its contents using the following functions:

* You can query a field's type by using [refmemunq field_view kind],
  which returns a [reflink field_kind] enum.
* You can query whether a field contains a certain type with `field::is_xxx`.
* You can get the underlying value with `field::as_xxx` and `field::get_xxx`.
  The `as_xxx` functions are checked (they will throw an exception if the
  actual type doesn't match), while the `get_xxx` are unchecked (they result
  in undefined behavior on type mismatch).
* You can stream fields and compare them for equality.

For example:

[overview_using_fields]

`NULL` values are represented as field objects having `kind() == field_kind::null`.
You can check whether a value is `NULL` or not using [refmemunq field_view is_null].
This is how `NULL`s are typically handled:

[overview_handling_nulls]

Every MySQL type is mapped to a single C++ type. The following table shows these mappings:

[table:accessors
    [
        [`field_kind`]
        [C++ type]
        [MySQL types]
        [`is` accessor]
        [`as` accessor]
        [`get` accessor]
    ]
    [
        [`int64`]
        [`std::int64_t`]
        [__TINYINT__, __SMALLINT__, __MEDIUMINT__, __INT__, __BIGINT__]
        [[refmemunq field_view is_int64]]
        [[refmemunq field_view as_int64]]
        [[refmemunq field_view get_int64]]
    ]
    [
        [`uint64`]
        [`std::uint64_t`]
        [Unsigned __TINYINT__, __SMALLINT__, __MEDIUMINT__, __INT__, __BIGINT__, __YEAR__, __BIT__]
        [[refmemunq field_view is_uint64]]
        [[refmemunq field_view as_uint64]]
        [[refmemunq field_view get_uint64]]
    ]
    [
        [`string`]
        [
            [reflink string_view] for `field_view`
            
            `std::string` for `field`
        ]
        [
            __CHAR__, __VARCHAR__, __TEXT__ (all sizes), __ENUM__, __SET__, __DECIMAL__, __NUMERIC__, __JSON__
        ]
        [[refmemunq field_view is_string]]
        [[refmemunq field_view as_string]]
        [[refmemunq field_view get_string]]
    ]
    [
        [`blob`]
        [
            [reflink blob_view] for `field_view`
            
            [reflink blob] for `field`
        ]
        [__BINARY__, __VARBINARY__,  __BLOB__  (all sizes), __GEOMETRY__]
        [[refmemunq field_view is_blob]]
        [[refmemunq field_view as_blob]]
        [[refmemunq field_view get_blob]]
    ]
    [
        [`float_`]
        [`float`]
        [__FLOAT__]
        [[refmemunq field_view is_float]]
        [[refmemunq field_view as_float]]
        [[refmemunq field_view get_float]]
    ]
    [
        [`double_`]
        [`double`]
        [__DOUBLE__]
        [[refmemunq field_view is_double]]
        [[refmemunq field_view as_double]]
        [[refmemunq field_view get_double]]
    ]
    [
        [`date`]
        [[reflink date]]
        [__DATE__]
        [[refmemunq field_view is_date]]
        [[refmemunq field_view as_date]]
        [[refmemunq field_view get_date]]
    ]
    [
        [`datetime`]
        [[reflink datetime]]
        [__DATETIME__, __TIMESTAMP__]
        [[refmemunq field_view is_datetime]]
        [[refmemunq field_view as_datetime]]
        [[refmemunq field_view get_datetime]]
    ]
    [
        [`time`]
        [[reflink time]]
        [__TIME__]
        [[refmemunq field_view is_time]]
        [[refmemunq field_view as_time]]
        [[refmemunq field_view get_time]]
    ]
    [
        [`null`]
        []
        [Any of the above, when they're `NULL`]
        [[refmemunq field_view is_null]]
        []
        []
    ]
]

[link mysql.fields This section] contains more information about fields.

[endsect]

[section:statements Using prepared statements]

Until now, we've used simple text queries that did not contain any user-provided input.
In the real world, most queries will contain some piece of user-provided input.

One approach could be to use string concatenation to construct a SQL query from user input,
and then execute it using `query()`. Avoid this approach as much as possible, as it can lead
to [*SQL injection vulnerabilities]. Instead, [*use prepared statements].

Prepared statements are server-side objects that represent a parameterized query. A statement is
represented using the [reflink statement] class, which is a lightweight object holding a
handle to the server-side prepared statement.

Let's say you've got an inventory table, and you're writing a command-line program to get products
by ID. You've got the following table definition:

[overview_statements_setup]

You can prepare a statement to retrieve products by ID using:

[overview_statements_prepare]

You can execute the statement using [refmem connection execute_statement]:

[overview_statements_execute]

The `statement` object is passed as first parameter, which tells the server which
statement it should execute. Actual parameters are passed as the second argument,
as a `std::tuple`. You must pass as many parameters as `?` placeholders the statement has.

To learn more about prepared statements, please refer to [link mysql.prepared_statements this section].

[endsect]

[section Multi-function operations]

Until now, we've been using [refmem connection query] and [refmem connection execute_statement], which
execute some SQL and read all generated data into an in-memory `results` object.

Some use cases may not fit in this simple pattern. For example:

* When reading a very big resultset, it may not be efficient (or even possible) to completely
  load it in memory. Reading rows in batches may be more adequate.
* If rows contain very long `TEXT` or `BLOB` fields, it may not be adequate to copy these values
  from the network buffer into the `results` object. A view-based approach may be better.

For these cases, we can break the `query()` or `execute_statement()` operation into several steps,
using a ['multi-function operation] (the term is coined by this library). This example reads an entire
table in batches, which can be the case in an ETL process:

[overview_multifn]

[warning
    Once you start a multi-function operation with [refmem connection start_query] or [refmem connection start_statement_execution],
    the server immediately sends all rows to the client. [*You must read all rows] before engaging in further operations.
    Otherwise, you will encounter packet mismatches, which can lead to bugs and vulnerabilities!
]

Multi-function operations are powerful but complex. Only use them when there is a strong reason to do so.
Please refer to [link mysql.multi_function this section] for more information on these operations.

[endsect]

[section:errors Error handling]

The functions we've been using communicate errors throwing exceptions. There are also non-throwing
overloads that use error codes.

If the server fails to fulfill a request (for example, because the provided SQL was invalid or a
referenced table didn't exist), the operation is considered failed and will return an error.
The server provides an error message that
can be accessed using the [reflink diagnostics] class. For example:

[overview_errors_sync_errc]

With exceptions, this would be:

[overview_errors_sync_exc]

[endsect]

[section:async Asynchronous functions]

As with Boost.Asio, every sync operation has an async counterpart. This library follows
Asio's async model, so you may use async operations with any valid Asio `CompletionToken`, including callbacks
and coroutines.

For example, if you can use C++20, you can write:

[overview_async_coroutinescpp20]

The [link mysql.examples examples section] contains material that can help you.
[link mysql.async This section] also provides more info on this topic. 

[h4 Single outstanding operation per connection]

At any given point in time, a `connection` may only have a single async operation outstanding.
This is because the connection uses the underlying `Stream` object directly, without any locking
or queueing. If you perform several async operations concurrently on a single connection without any
serialization, the stream may interleave reads and writes from different operations, leading to undefined behavior.

For example, [refmem connection async_query] performs both reads and writes.
Doing this is illegal and should be avoided:

[overview_async_dont]

If you need to perform queries in parallel, open more connections to the server.

[endsect]

[endsect]
