[/
    Copyright (c) 2019-2024 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:tutorial_connection_pool Tutorial 6: Connection pools and timeouts]

All our programs until now have used one-shot connections.
They also didn't feature any fault tolerance:
if the server is unavailable, our program throws an exception
and terminates. Most real world scenarios require
long-lived, reliable connections, instead.

In this tutorial, we will implement a server for a simple request-reply
protocol. The protocol allows clients to retrieve the full name of
an employee given their ID.
We will use [reflink connection_pool] to maintain a set of healthy connections
that we can use when a client connects to our server.




[heading The protocol]

The protocol is TCP based, and can be described as follows:

* After connecting, the client sends a message containing the employee ID,
  encoded as an 8-byte, big-endian integer.
* The server replies with a string containing the employee full name,
  or "NOT_FOUND", if the ID doesn't match any employee.
* The connection is closed after that.

This protocol is intentionally overly simplistic, and
shouldn't be used in production. See our
[link mysql.examples.connection_pool HTTP examples]
for more advanced use cases.




[heading Creating a connection pool]

[reflink connection_pool] is an I/O object that contains
[reflink any_connection] objects, and can be
constructed from an execution context and a [reflink pool_params]
config struct:

[tutorial_connection_pool_create]

A single connection pool is usually created per application.

[refmem connection_pool async_run] should be called once per pool:

[tutorial_connection_pool_run]






[heading Using pooled connections]

Let's first write a coroutine that encapsulates database access.
Given an employee ID, it should return the string to be sent as response to the client.
Don't worry about error handling for now - we will take care of it in the next tutorial.

When using a pool, we don't need to explicitly create, connect or close connections.
Instead, we use [refmem connection_pool async_get_connection] to obtain them from the pool:

[tutorial_connection_pool_get_connection]

[reflink pooled_connection] is a wrapper around [reflink any_connection],
with some pool-specific additions. We can use it like a regular connection:

[tutorial_connection_pool_use]

When a [reflink pooled_connection] is destroyed, the connection is returned
to the pool. The underlying connection will be cleaned up using a lightweight
session reset mechanism and recycled.
Subsequent [refmemunq connection_pool async_get_connection]
calls may retrieve the same connection. This improves efficiency,
since session establishment is costly.

Putting all pieces together, our coroutine becomes:

[tutorial_connection_pool_db]




[heading Handling a client session]

Let's now build a function that handles a client sessions,
invoking the database access logic in the process:

[tutorial_connection_pool_session]




[heading Listening for connections]

We now need logic to accept incoming TCP connections.
We will use an `asio::ip::tcp::acceptor` object
in our main coroutine to accomplish it:

[tutorial_connection_pool_acceptor_setup]

Our program will accept connections in a loop:

[tutorial_connection_pool_acceptor_loop]





[heading Setting a timeout for client sessions]

We mentioned that [refmemunq connection_pool async_get_connection] waits
for a client connection to become available before completing.
If the server is unavailable or credentials are invalid,
`async_get_connection` may wait indefinitely. This is a problem
for both development and production.
[asioreflink cancel_after cancel_after] can help us, but we
should first understand what a
[@boost:/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.completion_tokens_and_handlers completion token]
is.

A completion token is an object that determines what to do
when an asynchronous operation completes, and can be passed
as the last argument to async functions. If nothing is passed,
the default completion token applies, which returns an object
that can be co_await'ed. This is what we have been doing until now.

A callback is also a completion token. When a callback is passed to
an initiation function, it will be invoked when the operation completes.
We've also used this before, with `co_spawn`.

Completion tokens are usually generic: once you learn how to use one,
it can be applied to all Asio-compliant async operations.

[asioreflink cancel_after cancel_after] wraps a completion token
to produce a new token that issues a cancellation if the
operation it's passed to doesn't complete in a certain amount
of time. We can apply it to operations in Boost.MySQL like this:

[tutorial_connection_pool_get_connection_timeout]

While this works, it's usually better to set the timeout
at the session level. `asio::co_spawn` is an async operation, too,
so we can use completion tokens with it. Let's modify our acceptor loop:

[tutorial_connection_pool_coro_timeout]




[heading Waiting for signals]

We need a way to stop our program. We will use an `asio::signal_set` object
to catch signals, and call `io_context::stop` when Ctrl-C is pressed:

[tutorial_connection_pool_signals]




[heading Wrapping up]

Full program listing for this tutorial is [link mysql.examples.tutorial_connection_pool here].

For simplicity, we've left error handling out of this tutorial.
This is usually very important in a server like the one we've written,
and is the topic of our [link mysql.tutorial_error_handling next tutorial].

[endsect]