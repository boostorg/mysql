[/
    Copyright (c) 2019-2024 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:tutorial_error_handling Tutorial 7: Error handling]

The [link mysql.tutorial_connection_pool previous tutorial]
did not include any error handling. When an error is encountered
while talking to the DB or the client, an exception is thrown and
the program terminates. This is undesirable in server programs like the one we're writing.

To add error handling, we can just add try/catch blocks to prevent exception propagation.
However, many code bases discourage the use of exceptions for non-exceptional circumstances,
like I/O errors. In this tutorial, we will learn how to manage I/O errors without exceptions
by using [asioreflink as_tuple as_tuple] and error codes.


[heading Error handling strategy]

There are two kind of I/O errors that our program can encounter:

* Reading and writing to the client may fail. This can happen if
  the client program is faulty or a network error happens.
  In this case, we should log the problem and close the connection.
* Talking to the database may fail. This can happen if [refmemunq connection_pool async_get_connection]
  is cancelled because of a timeout. In this case, we will return a special string (`"ERROR"`)
  to the client, signalling that we can't fulfill the request, and log the problem.

Additionally, we will modify how we use `asio::cancel_after` to make the system more reliable.




[heading Completion tokens]

Before proceeding, we need to understand what a completion token is.
The concepts in this section are not specific to Boost.MySQL, but apply
to Asio and all Asio-compatible libraries. Since Asio docs can be terse,
we explain them here to facilitate the reader.

All asynchronous operations accept an optional parameter specifying what
to do when the operation completes. If present, this parameter is always the last one.
This last parameter is the
[@boost:/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.completion_tokens_and_handlers completion token].

Callbacks are valid completion tokens. Taking [refmemunq connection_pool async_get_connection]
as example, the following is valid:

```
// Function to call when async_get_connection completes
auto on_available_connection = [](boost::system::error_code ec, mysql::pooled_connection conn) {
  // Do something useful with the connection 
};

// Start the operation. on_available_connection will be called when the operation
// completes. on_available_connection is the completion token.
pool.async_get_connection(on_available_connection);
```

We have already been using this when creating coroutines with `asio::co_spawn`.
This function is also an async operation, and the callback we pass as final parameter,
a completion token.

You might consider using callbacks if your compiler doesn't support coroutines,
or just by personal preference. [link mysql.examples.callbacks This example]
demonstrates how to use them.

If you don't specify a completion token, the operation's [*default completion token]
will be used. This is usually `asio::deferred` or `mysql::with_diagnostics(asio::deferred)`.
[footnote [reflink with_diagnostics] is an adapter completion token that enhances
thrown exceptions with a diagnostic string supplied by the server.
`mysql::with_diagnostics(asio::deferred)` is otherwise equivalent to `asio::deferred`.].
These tokens transform asynchronous operations into awaitables,
so we can use them in C++20 coroutines.

The default completion token for [refmemunq connection_pool async_get_connection] is
`mysql::with_diagnostics(asio::deferred)`. This means that the following two are equivalent:

```
// These two lines are equivalent.
// Both of them can be read as "I want to use C++20 coroutines as my completion style"
auto conn1 = co_await pool.async_get_connection();
auto conn2 = co_await pool.async_get_connection(mysql::with_diagnostics(asio::deferred));
```

Completion tokens are generic: once you learn how to use one, you can use it
with any Asio-compliant async operation. This includes all functions in Boost.Asio,
Boost.MySQL, Boost.Beast and Boost.Redis. We say that operations in these libraries
are compliant with Asio's universal async model. Writing these is hard, but they're easy to use!





[heading Adapter completion tokens]


* There are also adapter completion tokens. They modify something about
  how the operation executes, and can be used with different completion
  tokens. They don't actually specify what to do on completion - it is the
  completion token being adapted the one that dictates this.

* We have seen one of these tokens: asio::cancel_after, which
  sets a timeout to the operation. By default, asio::cancel_after
  and similar tokens wrap the default completion token for an operation.

This means that this:

```
auto conn = co_await pool.async_get_connection(asio::cancel_after(std::chrono::seconds(20)));
```

Is equivalent to this:

```
auto conn = co_await pool.async_get_connection(
  asio::cancel_after(std::chrono::seconds(20), mysql::with_diagnostics(asio::deferred))
);
```

Actually, [reflink with_diagnostics] is also a completion token adapter
that enhances thrown exceptions. Other than that, `mysql::with_diagnostics(asio::deferred)`
is equivalent to `asio::deferred`.












[heading asio::as_tuple]

[asioreflink as_tuple as_tuple] is another adapter completion token
that can be used to prevent exceptions.
To understand why, let's recall this snippet from the previous tutorial:

[tutorial_error_handling_get_connection_exc]

If we have a look at the documentation for [refmemunq connection_pool async_get_connection],
the "Handler signature" paragraph states that the handler signature for this operation is
`void(boost::system::error_code, mysql::pooled_connection)`.
Why are we not seeing the error code?

When an awaitable in Asio is co_await'ed, the first handler argument is inspected.
If it's an `error_code` that indicates a failure, an exception is thrown.
The `error_code` is removed from the argument list,
leaving a `mysql::pooled_connection` only.

[asioreflink as_tuple as_tuple]
modifies the handler signature, packing all arguments into a `std::tuple`.
All the properties of adapter completion tokens that we have learnt
in the previous session also apply. This is how it's used:

[tutorial_error_handling_get_connection_as_tuple]

This inhibits the automatic error code checks, preventing exceptions on I/O failure.

In practice, it's usually better to use structured bindings:

```
// ec is an error_code, conn is the mysql::pooled_connection
// Apply a timeout and don't throw on error
auto [ec, conn] = co_await pool.async_get_connection(asio::as_tuple);
```

Adapter tokens can be combined. To apply a timeout to the operation
while avoiding exceptions, you can use:

```
// ec is an error_code, conn is the mysql::pooled_connection
// Apply a timeout and don't throw on error
auto [ec, conn] = co_await pool.async_get_connection(
  asio::cancel_after(std::chrono::seconds(20), asio::as_tuple)
);
```





[heading Using asio::as_tuple for database code]

If we apply [asioreflink as_tuple as_tuple] to our database logic, we have:

TODO: add the timeout here
[tutorial_error_handling_db_nodiag]

Note that we're no longer using `asio::cancel_after` for the timeout.




[heading Diagnostics objects]

While what we wrote works, it can be improved. When a database operation fails, the server
may supply an error string with information about what went wrong. Boost.MySQL may also
generate such strings in certain cases. We get this automatically
when using exceptions. The library throws [reflink error_with_diagnostics] objects
(even when using coroutines), which inherit from `boost::system::system_error`
and have a [refmemunq error_with_diagnostics get_diagnostics] member.

When using error codes, we need to handle diagnostics manually.
All functions in Boost.MySQL are overloaded to accept a [reflink diagnostics]
output parameter. It will be populated with extra information in case of error.

Let's update our code to use diagnostics:

[tutorial_error_handling_db]

The error logging function looks like this:

[tutorial_error_handling_log_error]

[refmem diagnostics client_message] and [refmem diagnostics server_message] differ
in their origin. Client messages never contain user-supplied input, and can always
be used safely. Server messages may contain user input, and should be treated with
more caution (logging them is fine).





[heading Using asio::as_tuple with client reads and writes]

Finally, let's apply [asioreflink as_tuple as_tuple] to client communication:

[tutorial_error_handling_session]






[heading Setting a timeout for client sessions]

`async_get_connection` is not the only function that may take long to complete.
A network error or an unresponsive client may keep client connections
open for longer than required, consuming server resources.
It may be a good idea to set a timeout to not just a single operation,
but to the overall client session. Fortunately, asio::co_spawn is
also an async operation, so all what we have learn about completion tokens apply.
Let's modify our acceptor loop:

TODO: code

TODO: is this not already in code?
If the spawned coroutine doesn't finish in time, Asio will cancel the I/O
operation the coroutine is waiting for in this moment. This will make the I/O
operation fail, as if a network error had been encountered. The coroutine
will continue to execute until it returns or throws.

Doing this reliably requires an extra piece of code. If our client session is
waiting for a database operation when it cancels (i.e. it's running `get_employee_details`),
an error result will be returned, and we will try to write it to the client.
This is not what we want: writing may block again, effectively surpassing the timeout we set.
Additionally, coroutines have memory regarding cancellation: if you call co_await
on an async operation after the coroutine has been cancelled, an exception is thrown.
To prevent this exception, we just need to check the cancellation state after
`get_employee_details` returns:

CODE

With these additions, the session handler becomes:

CODE



[heading Wrapping up]

Full program listing for this tutorial is [link mysql.examples.tutorial_error_handling here].

This concludes our tutorial series. You can now look at the [link mysql.overview overview section]
to learn more about the library features, or to the [link mysql.examples example section]
if you prefer to learn by doing.

[endsect]