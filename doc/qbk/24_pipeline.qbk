[/
    Copyright (c) 2019-2024 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:pipeline (Experimental) Pipelines]
[nochunk]

Most connection functions (like [refmemunq any_connection execute], [refmemunq any_connection prepare_statement]
and their async counterparts) behave sequentially: they write a single request to the server
and then wait for its response. Thus, running N operations requires N round trips to the server.

Pipelines coalesce several requests into a single message, so it can be written as a single batch.
This can increase efficiency by saving round-trips.

[warning
    The protocol doesn't include explicit support for pipelines. [*From the server's point of view,
    a pipeline is just a sequence of unrelated requests]. The server will try to execute all stages
    in the pipeline, regardless of the result of previous steps. Pipelines are considered
    an [*advanced feature]. See (TODO: like) pitfalls.
]

[note
    This feature is experimental. Its API may change in subsequent releases.
]

[heading Use cases]

You should use pipelines for lightweight operations, dominated by round-trip time. Typical examples include:

* Preparing several statements, in batch.
* Executing and closing a statement in a single round-trip.
* Running connection setup code, which may imply operations like [refmemunq any_connection reset_connection],
  [refmemunq any_connection set_character_set] or preparing statements. [reflink connection_pool] uses
  pipelines to clean up connections for re-use.

You should [*avoid] pipelines for the following cases:

* When you can achieve the same functionality using a combination of
  [link mysql.multi_resultset.multi_queries multi-queries] and [link mysql.sql_formatting client-side SQL formatting].
  Multi-queries will stop after the first error, which is usually what you want. See [link mysql.pipeline.pitfalls this section] for more info.
* When running heavyweight queries, where the gains in round-trip time are not significant.
* When there are dependencies between stages in the pipeline. Lack of protocol support makes this use case impossible.

If you're not sure, don't use this feature.






[heading Pipeline requests and responses]

There are two interfaces to pipelines: dynamic ([reflink pipeline_request]) and static
([reflink static_pipeline_request]). Both are C++11 compatible.

To run a dynamic pipeline, create a request object describing what should the pipeline do:

```
// Create a pipeline request and add three stages to it.
// When run, this pipeline will set the connection's character set to utf8mb4
// and prepare two statements.
pipeline_request req;
req.add(set_character_set_stage(utf8mb4_charset))
    .add(prepare_statement_stage("INSERT INTO audit_log (t, msg) VALUES (?, ?)"))
    .add(prepare_statement_stage("INSERT INTO employee (company_id, first_name, last_name) VALUES (?, ?, ?)"));
```

Use [refmem pipeline_request add] with (TODO: link) any of the stage types to add stages your pipeline.

To actually run the pipeline, create a response object and call
[refmem any_connection run_pipipeline] or [refmemunq any_connection async_run_pipeline]:

```
// Run the pipeline request req, and store responses into res
// any_stage_response is a variant-like type that can the response
// of any stage type (including results and statements).
std::vector<any_stage_response> res;
conn.run_pipipeline(req, res);
```

Finally, you can access the statements using:

```
// The 2nd and 3rd stages were prepare statements, so res[1] and res[2]
// contain statement objects
statement stmt1 = res[1].as_statement();
statement stmt2 = res[2].as_statement();
```




[heading Static pipelines]

If the type and number of stages in your pipeline is known at compile-time, you can use
static pipelines, instead. The mechanics are similar, except that some checks are moved
to compile-time. The pipeline in the previous example can be rewritten as:

```
// Create a pipeline request containing with three stages.
// When run, this pipeline will set the connection's character set to utf8mb4
// and prepare two statements.
// req is a static_pipeline_request<set_character_set_stage, prepare_statement_stage, prepare_statement_stage>
auto req = make_pipeline_request(
    set_character_set_stage(utf8mb4_charset),
    prepare_statement_stage("INSERT INTO audit_log (t, msg) VALUES (?, ?)"),
    prepare_statement_stage("INSERT INTO employee (company_id, first_name, last_name) VALUES (?, ?, ?)")
);

// Create a response object. Instead of vectors, static pipelines use tuples.
// res is a std::tuple<set_character_set_stage::response_type, 
//     prepare_statement_stage::response_type, prepare_statement_stage::response_type>
// Each stage type has an associated response type
decltype(req)::response_type res;


// Run the pipeline
conn.run_pipipeline(req, res);

// Access your statements
statement stmt1 = std::get<1>(res).value();
statement stmt2 = std::get<2>(res).value();
```

If your use case allows it, prefer the static interface.







[heading:error Error handling]

If any of the pipeline stages result in an error, the entire [refmemunq any_connection run_pipipeline] operation
is considered failed. This means that [*if `run_pipipeline` completed successfully, all stages succeeded]. Recall that
[*all stages are always run, regardless of the outcome of previous stages]. 

If `run_pipipeline` fails, you can check which steps succeeded and failed by inspecting responses.
Response types like [refmem prepare_statement_stage response_type] are aliases for
[link mysql.error_handling.system_result `boost::system::result`], a vocabulary type that
can contain either a value or an error. For instance:

```
// The second step in the pipeline will fail, the other ones will succeeded
auto req = make_pipeline_request(
    set_character_set_stage(utf8mb4_charset),
    prepare_statement_stage("INSERT INTO bad_table (t, msg) VALUES (?, ?)"), // will fail
    prepare_statement_stage("INSERT INTO employee (company_id, first_name, last_name) VALUES (?, ?, ?)")
);

decltype(req)::response_type res;
error_code ec;
diagnostics diag;

conn.run_pipipeline(req, res, ec, diag);
BOOST_TEST(ec == common_server_errc::whatever);
BOOST_TEST(std::get<0>(res).code == error_code());
BOOST_TEST(std::get<1>(res).error().code == common_server_errc::whatever);
BOOST_TEST(std::get<2>(res).error().code == error_code());
```

The [reflink errcode_with_diagnostics] error type, which contains an `error_code`
and a [reflink diagnostics] string, is used throughout the module.




[heading:p√¨tfalls Potential pitfalls]

All requests in the pipeline are always run, regardless of the outcome of previous requests. As a result, some pipelines can behave non-intuitively:

```
// This doesn't behave correctly - DO NOT DO THIS
// COMMIT will be run even if one of the INSERTs fail, which defeats the purpose of the transaction
auto req = make_pipeline_request(
    execute_stage("START TRANSACTION"),
    execute_stage("INSERT INTO employee VALUES (...)"),
    execute_stage("INSERT INTO logs VALUES (...)"),
    execute_stage("COMMIT"),
);
```

Pipelines aren't the best fit here. Instead, you can express the same logic using semicolon-separated queries and [reflink format_sql]:

```
const char* sql = 
    "START TRANSACTION;"
    "INSERT INTO employee VALUES (...);"
    "INSERT INTO logs VALUES (...);"
    "COMMIT"
;

// If an error is encountered in any of the INSERTs, COMMIT won't run
results r;
conn.execute(sql, r);
```

Pipeline stages are run sequentially by the server. If any of the stages involves a heavyweight query, the server won't process subsequent stages until the query completes.



* Reference table

[table:reference
    [
        [Stage type]
        [Description]
        [Example]
        [Equivalent to...]
        [Response type]
    ]
    [
        [[reflink execute_stage]]
        [
            Executes a text query or a prepared statement
        ]
        [
            ```
            // Text query
            req.add(execute_stage("SELECT 1"));

            // Prepared statement, with number of parameters known at compile time
            req.add(execute_stage(stmt, {42, "abc"}));

            // Prepared statement, with number of parameters unknown at compile time
            std::vector<field_view> params { /*... */ };
            req.add(execute_stage(stmt, params));
            ```
        ]
        [
            [reflink any_connection execute]:
            ```
            // Text query
            conn.execute("SELECT 1", result);

            // Prepared statement, with number of parameters known at compile time
            conn.execute(stmt.bind(42, "abc"), result);

            // Prepared statement, with number of parameters unknown at compile time
            std::vector<field_view> params { /*... */ };
            conn.execute(stmt.bind(params.begin(), params.end()), result);
            ```
        ]
        [
            Dynamic: [reflink any_stage_response] containing [reflink results]
            ([refmemunq any_stage_response as_results], [refmemunq any_stage_response get_results], [refmemunq any_stage_response has_results])
            or an error.

            Static: `system::result<`[reflink results], [reflink errcode_and_diag]`>`
        ]
    ]
    [
        [[reflink prepare_statement_stage]]
        [
            Prepares a statement server-side
        ]
        [
            ```
            req.add(prepare_statement_stage("SELECT * FROM employee WHERE id = ?"));
            ```
        ]
        [
            [reflink any_connection prepare_statement]:
            ```
            conn.prepare_statement("SELECT * FROM employee WHERE id = ?");
            ```
        ]
        [
            Dynamic: [reflink any_stage_response] containing a [reflink statement]
            ([refmemunq any_stage_response as_statement], [refmemunq any_stage_response get_statement], [refmemunq any_stage_response has_statement])
            or an [refmemunq any_stage_response error].

            Static: `system::result<`[reflink statement], [reflink errcode_and_diag]`>`
        ]
    ]
    [
        [Close statement]
        [
            Deallocates a prepared statement[br]
        ]
        [
            ```
            req.add(close_statement_stage(stmt));
            ```
        ]
        [
            [reflink any_connection close_statement]:
            ```
            conn.close_statement(stmt);
            ```
        ]
        [
            Dynamic: [reflink any_stage_response] containing a (possibly empty) [refmemunq any_stage_response error].

            Static: [reflink errcode_and_diag]
        ]
    ]
    [
        [Reset connection]
        [
            Resets server-side session state
        ]
        [
            ```
            req.add(reset_connection_stage());
            ```
        ]
        [
            [reflink any_connection reset_connection]
        ]
        [
            Dynamic: [reflink any_stage_response] containing a (possibly empty) [refmemunq any_stage_response error].

            Static: [reflink errcode_and_diag]
        ]
    ]
    [
        [Set character set]
        [
            Sets the connection's current character set
        ]
        [
            ```
            req.add(set_character_set_stage(utf8mb4_charset));
            ```
        ]
        [
            [reflink any_connection set_character_set]:
            ```
            conn.set_character_set(utf8mb4_charset);
            ```
        ]
        [
            Dynamic: [reflink any_stage_response] containing a (possibly empty) [refmemunq any_stage_response error].

            Static: [reflink errcode_and_diag]
        ]
    ]
]






[endsect]