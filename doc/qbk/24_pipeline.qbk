[/
    Copyright (c) 2019-2024 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:pipeline (Experimental) Pipelines]
[nochunk]

Functions like [refmemunq any_connection execute], [refmemunq any_connection prepare_statement]
and their async counterparts work in a half-duplex request-response fashion:
they write a single request to the server and wait for its response.
Pipelines can increase efficiency by coalescing several requests into a single message, saving round-trips to the server.

[warning
    The MySQL client/server protocol doesn't have explicit support for pipelines. [*From the server's point of view,
    a pipeline is just a sequence of unrelated requests]. The server will try to execute all stages
    in each pipeline, regardless of the result of previous steps. Pipelines are considered
    an [*advanced feature]. Please read [link mysql.pipeline.pitfalls the pitfalls section] for more info.
]

[note
    This feature is experimental. Its API may change in subsequent releases.
]

[heading Use cases]

You should use pipelines for lightweight operations, dominated by round-trip time. Typical examples include:

* Running connection setup code, involving operations like [refmemunq any_connection reset_connection],
  [refmemunq any_connection set_character_set] or preparing statements. [reflink connection_pool] uses
  pipelines to clean up connections for re-use.
* Preparing several statements, in batch.
* Executing and closing a statement in a single round-trip.


You should [*avoid] pipelines for the following cases:

* When you can achieve the same functionality using semicolon-separated queries
  (thus using [link mysql.multi_resultset.multi_queries multi-queries] and [link mysql.sql_formatting client-side SQL formatting]).
  Multi-queries will stop after the first error, which is usually what you want. See [link mysql.pipeline.pitfalls this section] for more info.
* When running heavyweight queries, where the gains in round-trip time are not significant.
* When there are dependencies between stages in the pipeline. Lack of protocol support makes this use case impossible.

If you're not sure, don't use this feature.






[heading Pipeline requests and responses]

There are two interfaces to pipelines: dynamic ([reflink pipeline_request]) and static
([reflink static_pipeline_request]). Both are C++11 compatible.

To run a dynamic pipeline, create a request object describing what should the pipeline do:

```
// Create a pipeline request and add three stages to it.
// When run, this pipeline will set the connection's character set to utf8mb4
// and prepare two statements.
pipeline_request req;
req.add(set_character_set_stage(utf8mb4_charset))
    .add(prepare_statement_stage("INSERT INTO audit_log (t, msg) VALUES (?, ?)"))
    .add(prepare_statement_stage("INSERT INTO employee (company_id, first_name, last_name) VALUES (?, ?, ?)"));
```

Use [refmem pipeline_request add] with any of the [link mysql.pipeline.reference available stage types]
to add stages your pipeline.

To actually run the pipeline, create a response object and call
[refmem any_connection run_pipeline] or [refmemunq any_connection async_run_pipeline]:

```
// Run the pipeline request req, and store responses into res
// any_stage_response is a variant-like type that can store the response
// of any stage type (including results and statements).
std::vector<any_stage_response> res;
conn.run_pipeline(req, res);
```

Finally, you can access the statements using:

```
// The 2nd and 3rd stages were statement preparation requests,
// so res[1] and res[2] contain statement objects
statement stmt1 = res[1].as_statement();
statement stmt2 = res[2].as_statement();
```




[heading Static pipelines]

If the type and number of stages in your pipeline is known at compile-time, you can use
static pipelines, instead. The mechanics are similar, except that some checks are moved
to compile-time. The pipeline in the previous example can be rewritten as:

```
// Create a pipeline request containing three stages.
// When run, this pipeline will set the connection's character set to utf8mb4
// and prepare two statements.
// req is a static_pipeline_request<set_character_set_stage, prepare_statement_stage, prepare_statement_stage>
auto req = make_pipeline_request(
    set_character_set_stage(utf8mb4_charset),
    prepare_statement_stage("INSERT INTO audit_log (t, msg) VALUES (?, ?)"),
    prepare_statement_stage("INSERT INTO employee (company_id, first_name, last_name) VALUES (?, ?, ?)")
);

// Create a response object. Instead of vectors, static pipelines use tuples.
// Each stage type has an associated response type
// res is a std::tuple<set_character_set_stage::response_type, 
//     prepare_statement_stage::response_type, prepare_statement_stage::response_type>
decltype(req)::response_type res;


// Run the pipeline
conn.run_pipeline(req, res);

// Access your statements
statement stmt1 = std::get<1>(res).value();
statement stmt2 = std::get<2>(res).value();
```









[heading:error Error handling]

If any of the pipeline stages result in an error, the entire [refmemunq any_connection run_pipeline] operation
is considered failed. This means that [*if `run_pipipeline` completed successfully, all stages succeeded]. Recall that
[*all stages are always run, regardless of the outcome of previous stages]. 

If `run_pipipeline` fails, you can check which steps succeeded and failed by inspecting responses.
Response types like [refmem prepare_statement_stage response_type] are aliases for
[link mysql.error_handling.system_result `boost::system::result`], a vocabulary type that
can contain either a value or an error. For instance:

```
// The second step in the pipeline will fail, the other ones will succeeded
auto req = make_pipeline_request(
    set_character_set_stage(utf8mb4_charset),
    prepare_statement_stage("INSERT INTO bad_table (t, msg) VALUES (?, ?)"), // will fail
    prepare_statement_stage("INSERT INTO employee (company_id, first_name, last_name) VALUES (?, ?, ?)")
);

decltype(req)::response_type res;
error_code ec;
diagnostics diag;

conn.run_pipipeline(req, res, ec, diag);
BOOST_TEST(ec == common_server_errc::whatever);
BOOST_TEST(std::get<0>(res).code == error_code());
BOOST_TEST(std::get<1>(res).error().code == common_server_errc::whatever);
BOOST_TEST(std::get<2>(res).error().code == error_code());
```

The module uses [reflink errcode_with_diagnostics] as the error type,
which contains an `error_code` and a [reflink diagnostics] object.




[heading:pitfalls Potential pitfalls]

All requests in the pipeline are always run, regardless of the outcome of previous requests. As a result, some pipelines can behave non-intuitively:

```
// This doesn't behave correctly - DO NOT DO THIS
// The first INSERT will fail due to a failed foreign key check (there is no such company),
// but COMMIT will still be run, thus leaving us with an inconsistent data model
auto req = make_pipeline_request(
    execute_stage("START TRANSACTION"),
    execute_stage("INSERT INTO employee (first_name, last_name, company_id) VALUES ('John', 'Doe', 'bad')"),
    execute_stage("INSERT INTO logs VALUES ('Inserted 1 employee')"),
    execute_stage("COMMIT")
);
```

Pipelines aren't the best fit here. Instead, you can express the same logic using semicolon-separated queries:

```
const char* sql = 
    "START TRANSACTION;"
    "INSERT INTO employee (first_name, last_name, company_id) VALUES ('John', 'Doe', 'bad');"
    "INSERT INTO logs VALUES ('Inserted 1 employee');"
    "COMMIT"
;

// After the first INSERT fails, nothing else will be run. This is what we want.
// Note that you need to enable multi queries when connecting to be able to run this.
results r;
conn.execute(sql, r);
```

Pipeline stages are run sequentially by the server. If any of the stages involves a heavyweight query,
the server won't process subsequent stages until the query completes.



[heading:reference Pipeline stage reference]

In the table below, the following variables are assumed:

* `req` is a [reflink pipeline_request].
* `stmt` is a valid [reflink statement].
* `result` is a [reflink results] object.
* `conn` is an [reflink any_connection] object.

[table:reference
    [
        [Stage type]
        [Example]
        [Equivalent to...]
        [Response type]
    ]
    [
        [
            [reflink execute_stage][br][br]
            Behaves like [refmem any_connection execute]
        ]
        [
            ```
            // Text query
            req.add(execute_stage("SELECT 1"));

            // Prepared statement, with number of parameters known at compile time
            req.add(execute_stage(stmt, {42, "abc"}));

            // Prepared statement, with number of parameters unknown at compile time
            std::vector<field_view> params { /*... */ };
            req.add(execute_stage(stmt, params));
            ```
        ]
        [
            ```
            // Text query
            conn.execute("SELECT 1", result);

            // Prepared statement, with number of parameters known at compile time
            conn.execute(stmt.bind(42, "abc"), result);

            // Prepared statement, with number of parameters unknown at compile time
            std::vector<field_view> params { /*... */ };
            conn.execute(stmt.bind(params.begin(), params.end()), result);
            ```
        ]
        [
            [reflink results] or [reflink errcode_with_diagnostics]
        ]
    ]
    [
        [
            [reflink prepare_statement_stage][br][br]
            Behaves like [refmem any_connection prepare_statement]
        ]
        [
            ```
            req.add(prepare_statement_stage("SELECT * FROM employee WHERE id = ?"));
            ```
        ]
        [
            ```
            conn.prepare_statement("SELECT * FROM employee WHERE id = ?");
            ```
        ]
        [
            [reflink statement] or [reflink errcode_with_diagnostics]
        ]
    ]
    [
        [
            [reflink close_statement_stage][br][br]
            Behaves like [refmem any_connection close_statement]
        ]
        [
            ```
            req.add(close_statement_stage(stmt));
            ```
        ]
        [
            ```
            conn.close_statement(stmt);
            ```
        ]
        [
            Possibly empty [reflink errcode_with_diagnostics]
        ]
    ]
    [
        [
            [reflink reset_connection_stage][br][br]
            Behaves like [refmem any_connection reset_connection]
        ]
        [
            ```
            req.add(reset_connection_stage());
            ```
        ]
        [
            ```
            conn.reset_connection();
            ```
        ]
        [
            Possibly empty [reflink errcode_with_diagnostics]
        ]
    ]
    [
        [
            [reflink set_character_set_stage][br][br]
            Behaves like [refmem any_connection set_character_set]
        ]
        [
            ```
            req.add(set_character_set_stage(utf8mb4_charset));
            ```
        ]
        [
            ```
            conn.set_character_set(utf8mb4_charset);
            ```
        ]
        [
            Possibly empty [reflink errcode_with_diagnostics]
        ]
    ]
]


[endsect]