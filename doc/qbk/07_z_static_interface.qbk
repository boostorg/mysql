[/
    Copyright (c) 2019-2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
   
    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:static The statically-typed interface]
[nochunk]

[heading Row types]

As we discussed in the overview section, the static interface requires us to define
the shape of our rows at compile-time. The library will use this definition to validate
data returned from the server, and will place this data into the defined data structures.

You may use Boost.Describe structs or `std::tuple`s for this purpose.
In any case, using the static interface requires C++14.

[@boost:/libs/describe/index.html Boost.Describe structs] are the preferred way to define
row types. These are regular structs annotated with `BOOST_DESCRIBE_STRUCT`:

```
    struct post
    {
        int id;
        std::string title;
        std::string body;
    };

    // Add reflection capabilities to post
    BOOST_DESCRIBE_STRUCT(post, (), (id, title, body));

    conn.execute("SELECT id, title, body FROM posts", result);

    for (const post& p: result.rows())
    {
        // Process post as required
        std::cout << "Title: " << p.title << "\n" << p.body << std::endl;
    }
```

Columns in the query are matched to fields in the struct by name.
If a struct field cannot be matched to any query column, an error is issued.
Extra columns in the query are ignored.

If your query contains columns with names that don't qualify as C++ identifiers,
you can use SQL aliases. For example:

```
    struct statistics
    {
        std::string company;
        std::int64_t average;
        std::int64_t max_value;
    };
    BOOST_DESCRIBE_STRUCT(statistics, (), (average, max_value));

    static_results<statistics> result;
    conn.execute(R"%(
        SELECT
            AVG(salary) AS average,
            MAX(salary) AS max_value,
            company_id AS company
        FROM employees
        GROUP BY company_id
    )%", result);
```

You can also use `std::tuple`s as row types. This can be handy for simple queries:

```
    static_results<std::tuple<std::int64_t>> result;
    conn.execute("SELECT COUNT(*) FROM posts", result);
    std::cout << "Number of posts: " << std::get<0>(result.rows()[0]) << std::endl;
```

Fields in tuples are matched to query columns by order. The query must return as many
columns as fields the tuple has, at least. Any extra trailing columns in the query are ignored.

[heading Metadata checking]

The static interface will try to validate as soon as possible that the provided row type 
is compatible with the schema returned by the server. This process is known as [*metadata checking],
and is performed before reading any data.

* [*Type compatibility]: the C++ type must be able to represent any value that the MySQL type can represent.
  For example, `std::int32_t` is compatible with `TINYINT` (1 byte integer), but not with `BIGINT` (8 byte integer).
  For a full list of allowable field types, [link mysql.static.field_types refer to this table].
* [*Nullability]: if MySQL reports that a column can be `NULL`, your type must account for it. You can use
  `std::optional` or `boost::optional`, for example.

[note
    Optional types are not included by default. [*You must explicitly `#include`
    `<boost/mysql/typing/std_optional.hpp>` or `<boost/mysql/typing/boost_optional.hpp>`] to use them.
]

For example:

```
    struct post
    {
        int id;
        std::string title;
        std::optional<std::string> body;
    };
    BOOST_DESCRIBE_STRUCT(post, (), (id, title, body));
    
    // When retrieving rows, post::body::has_value() == false
    // if body is NULL in the database
```

You can also use [reflink non_null] to tell the static interface to disable
the nullability check for a certain field. For a usage example, see
TODO: link to the stored procedures example.

[heading Multi-resultset]

You can use the static interface when working with stored procedures or batched queries.
For example, given this procedure definition:

```
    const char* proc = R"%(
        CREATE PROCEDURE get_employees(pin_company_id IN CHAR(10))
        BEGIN
            START TRANSACTION READ ONLY;
            SELECT name, tax_id FROM company WHERE id = pin_company_id; 
            SELECT first_name, last_name FROM employee WHERE company_id = pin_employee_id;
        END
    )%";
```

We will get 3 resultsets here: one for each `SELECT` statement, and a final
empty resultset containing info about the `CALL` statement. We can call this
procedure like this:

```
    // Describes the first resultset
    struct company
    {
        std::string name;
        std::string tax_id;
    };
    BOOST_DESCRIBE_STRUCT(company, (), (name, tax_id));

    // Describes the second resultset
    struct employee
    {
        std::string first_name;
        std::string last_name;
    };
    BOOST_DESCRIBE_STRUCT(employee, (), (first_name, last_name));

    // The last resultset will always be empty.
    // We can use an empty tuple to represent it.
    using empty = std::tuple<>;

    // We must list all the resultset types the operation returns as template arguments
    static_results<company, employee, empty> result;
    conn.execute("CALL get_employees('HGS')", result);

    // We can use rows<0>() to access the rows for the first resultset
    if (result.rows<0>().empty())
    {
        std::cout << "Company not found" << std::endl;
    }
    else
    {
        const company& comp = result.rows<0>()[0];
        std::cout << "Company name: " << comp.name << ", tax_id: " << comp.tax_id << std::endl;
    }

    // rows<1>() will return the rows for the second resultset
    for (const employee& emp : result.rows<1>())
    {
        std::cout << "Employee " << emp.first_name << " " << emp.last_name << std::endl;
    }
```

Use [refmem static_results rows] with an explicit index to access each resultset's data.
You can also use explicit indices with the other accessor functions,
like [refmem static_results meta] and [refmem static_results last_insert_id].

[heading Multi-function operations]

The [reflink static_execution_state] class is the static equivalent of `execution_state`.
Like `static_results`, we must pass `static_execution_state` the row types returned by our query
at compile time:

```
    const char* query = "SELECT first_name, last_name FROM employee WHERE company_id = pin_employee_id";
    
    struct employee
    {
        std::string first_name;
        std::string last_name;
    };
    BOOST_DESCRIBE_STRUCT(employee, (), (first_name, last_name));

    static_execution_state<employee> st;
```

Like with `execution_state`, we use [refmem connection start_execution] to start the operation
and [refmem connection read_some_rows] to read rows. However, in this case we must pass in a
`boost::span` pointing to storage where our rows will live:

```
    std::array<employee, 20> employees;
    while (st.should_read_rows())
    {
        std::size_t read_rows = conn.read_some_rows(st, boost::span<employee>(ord));
        for (std::size_t i = 0; i < read_rows; ++i)
        {
            std::cout << "Employee " << employees[i].first_name << " " << employees[i].last_name << '\n';
        }
    }
```

`static_execution_state` can also be used with operations that return multiple resultsets.

TODO: point to examples

[heading Field type reference]

[table:field_types
    [
        [C++ type]
        [Compatible with...]
        [Header]
    ]
    [
        [`std::int8_t`]
        [
            __TINYINT__
        ]
        [Included by default]
    ]
    [
        [`std::uint8_t`]
        [
            __TINYINT__ `UNSIGNED`
        ]
        [Included by default]
    ]
    [
        [`std::int16_t`]
        [
            __TINYINT__[br]
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ [br]
            __YEAR__
        ]
        [Included by default]
    ]
    [
        [`std::uint16_t`]
        [
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ `UNSIGNED` [br]
            __YEAR__
        ]
        [Included by default]
    ]
    [
        [`std::int32_t`]
        [
            __TINYINT__, __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__, __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__, __MEDIUMINT__ `UNSIGNED`[br]
            __INT__[br]
            __YEAR__
        ]
        [Included by default]
    ]
    [
        [`std::uint32_t`]
        [
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__ `UNSIGNED`[br]
            __INT__ `UNSIGNED`[br]
            __YEAR__
        ]
        [Included by default]
    ]
    [
        [`std::int64_t`]
        [
            __TINYINT__,  __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__, __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__, __MEDIUMINT__ `UNSIGNED`[br]
            __INT__, __INT__ `UNSIGNED`[br]
            __BIGINT__[br]
            __YEAR__
        ]
        [Included by default]
    ]
    [
        [`std::uint64_t`]
        [
            __TINYINT__ `UNSIGNED`[br]
            __SMALLINT__ `UNSIGNED`[br]
            __MEDIUMINT__ `UNSIGNED`[br]
            __INT__ `UNSIGNED`[br]
            __BIGINT__ `UNSIGNED`[br]
            __YEAR__[br]
            __BIT__
        ]
        [Included by default]
    ]
    [
        [`float`]
        [
            __FLOAT__
        ]
        [Included by default]
    ]
    [
        [`double`]
        [
            __FLOAT__, __DOUBLE__[br]
        ]
        [Included by default]
    ]
    [
        [`date`]
        [
            __DATE__
        ]
        [Included by default]
    ]
    [
        [`datetime`]
        [
            __DATETIME__, __TIMESTAMP__
        ]
        [Included by default]
    ]
    [
        [`time`]
        [
            __TIME__
        ]
        [Included by default]
    ]
    [
        [`std::basic_string<char, Traits, Allocator>`]
        [
            __CHAR__, __VARCHAR__, __TEXT__[br]
            __ENUM__, __SET__[br]
            __JSON__[br]
            __DECIMAL__/__NUMERIC__
        ]
        [Included by default]
    ]
    [
        [`std::basic_vector<unsigned char, Allocator>`]
        [
            __BINARY__, __VARBINARY__, __BLOB__[br]
            __GEOMETRY__
        ]
        [Included by default]
    ]
    [
        [`std::optional<T>`]
        [
            Any type compatible with `T`
        ]
        [[include_file boost/mysql/typing/std_optional.hpp]]
    ]
    [
        [`boost::optional<T>`]
        [
            Any type compatible with `T`
        ]
        [[include_file boost/mysql/typing/std_optional.hpp]]
    ]
    [
        [[reflink2 non_null `non_null<T>`]]
        [
            Any type compatible with `T`
        ]
        [Included by default]
    ]
]

[endsect]
