//
// Copyright (c) 2019-2024 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef BOOST_MYSQL_WITH_PARAMS_HPP
#define BOOST_MYSQL_WITH_PARAMS_HPP

#include <boost/mysql/constant_string_view.hpp>

#include <boost/mysql/detail/format_sql.hpp>

#include <tuple>
#include <utility>

namespace boost {
namespace mysql {

/**
 * \brief A text query with bound parameters that can be executed.
 * \details
 * Conceptually, this class holds a query string, as a view, and a `std::tuple`
 * with format args to expand the query string.
 * Satisfies the `ExecutionRequest` concept. See \ref with_params for more info.
 */
template <BOOST_MYSQL_FORMATTABLE... Formattable>
struct with_params_t;

/**
 * \brief Type trait that applies the transformation performed by `std::make_tuple` to a single element.
 * \details
 * For example: \n
 *   - `make_tuple_element_t<int>` yields `int` \n
 *   - `make_tuple_element_t<const int&>` yields `int` \n
 *   - `make_tuple_element_t<std::reference_wrapper<int>>` yields `int&` \n
 * \n
 * Consult the `std::make_tuple` docs for more info.
 */
template <class T>
using make_tuple_element_t = typename std::tuple_element<0, decltype(std::make_tuple(std::declval<T&&>()))>::
    type;

/**
 * \brief Creates a query with parameters (client-side SQL formatting) that can be executed.
 * \details
 * Packs a query with replacement fields (i.e. `{}`) and a set of parameters into a
 * \ref with_params_t object that can be passed to `execute`, `start_execution` and its
 * async counterparts. When executed, client-side SQL formatting is invoked
 * to expand the provided query with the supplied parameters. The resulting query is then sent to
 * the server for execution.
 * \n
 * This function does not inspect the supplied query string and arguments - it just bundles them
 * into a tuple-like structure that can be passed to connection functions.
 * Errors like invalid query strings are detected when the resulting object is executed.
 * This function does not involve communication with the server.
 * \n
 * When executed, a text query is generated client-side using the format options
 * that the connection is using at the time (as per \ref any_connection::format_opts).
 * The supplied `args` are used for the format operation, after decaying them using `std::make_tuple`.
 * Formally, given a `conn` variable of \ref any_connection type, the query is generated as if the
 * following was called:
 * ```
 *   format_sql(
 *       query,
 *       conn.format_opts().value(),
 *       std::get<i>(std::make_tuple(std::forward<Formattable>(args)...))...
 *   );
 * ```
 *
 * \par Object lifetimes
 * This function copies the supplied `args` into the resulting \ref with_params_t
 * object using `std::make_tuple`. Like with `std::make_tuple`, you can disable
 * copying by passing `std::reference_wrapper` objects, which are converted to references.
 * This behavior makes the function safer for async operations involving deferred tokens.
 * \n
 * The query string is stored as a view, as a compile-time string should be used in most cases.
 *
 * \par Exception safety
 * Strong guarantee. Any exception thrown when copying `args` will be propagated.
 *
 * \par Errors
 * When passed to \ref any_connection::execute, \ref any_connection::start_execution or
 * its async counterparts, in addition to the usual network and server-generated errors,
 * `with_params_t` may generate the following errors: \n
 *   - Any errors generated by \ref format_sql. This includes errors due to invalid format
 *     strings and unformattable arguments (e.g. invalid UTF-8).
 *   - \ref client_errc::unknown_character_set if the connection does not know the
 *     character set it's using when the query is executed (i.e. \ref any_connection::current_character_set
 *     would return an error.
 */
template <class... Formattable>
auto with_params(constant_string_view query, Formattable&&... args)
    -> with_params_t<make_tuple_element_t<Formattable>...>;

}  // namespace mysql
}  // namespace boost

#include <boost/mysql/impl/with_params.hpp>

#endif
